From 8def273980e5a1486441ab1f9ba82fa9eea34112 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Sun, 16 Jul 2023 22:53:11 -0400
Subject: [PATCH] kernel: update rtl8125

Signed-off-by: Marty Jones <mj8263788@gmail.com>
---
 drivers/net/ethernet/realtek/r8125/Makefile   |  228 +-
 drivers/net/ethernet/realtek/r8125/r8125.h    |  109 +-
 .../net/ethernet/realtek/r8125/r8125_dash.h   |    0
 .../ethernet/realtek/r8125/r8125_firmware.c   |    0
 .../ethernet/realtek/r8125/r8125_firmware.h   |    0
 drivers/net/ethernet/realtek/r8125/r8125_n.c  | 2350 +++++++++++++----
 .../net/ethernet/realtek/r8125/r8125_ptp.c    |    0
 .../net/ethernet/realtek/r8125/r8125_ptp.h    |    0
 .../ethernet/realtek/r8125/r8125_realwow.h    |    0
 .../net/ethernet/realtek/r8125/r8125_rss.c    |    0
 .../net/ethernet/realtek/r8125/r8125_rss.h    |    0
 .../net/ethernet/realtek/r8125/rtl_eeprom.c   |    0
 .../net/ethernet/realtek/r8125/rtl_eeprom.h   |    0
 drivers/net/ethernet/realtek/r8125/rtltool.c  |    0
 drivers/net/ethernet/realtek/r8125/rtltool.h  |    0
 15 files changed, 2157 insertions(+), 530 deletions(-)
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/Makefile
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_dash.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_firmware.c
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_firmware.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_n.c
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_ptp.c
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_ptp.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_realwow.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_rss.c
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/r8125_rss.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/rtl_eeprom.c
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/rtl_eeprom.h
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/rtltool.c
 mode change 100755 => 100644 drivers/net/ethernet/realtek/r8125/rtltool.h

--- a/drivers/net/ethernet/realtek/r8125/Makefile
+++ b/drivers/net/ethernet/realtek/r8125/Makefile
@@ -4,7 +4,7 @@
 # r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
 # controllers with PCI-Express interface.
 #
-# Copyright(c) 2021 Realtek Semiconductor Corp. All rights reserved.
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the Free
@@ -35,10 +35,10 @@ ENABLE_REALWOW_SUPPORT = n
 ENABLE_DASH_SUPPORT = n
 ENABLE_DASH_PRINTER_SUPPORT = n
 CONFIG_DOWN_SPEED_100 = n
-CONFIG_ASPM = y
+CONFIG_ASPM = n
 ENABLE_S5WOL = y
 ENABLE_S5_KEEP_CURR_MAC = n
-ENABLE_EEE = n
+ENABLE_EEE = y
 ENABLE_S0_MAGIC_PACKET = n
 ENABLE_TX_NO_CLOSE = y
 ENABLE_MULTIPLE_TX_QUEUE = y
@@ -49,73 +49,161 @@ ENABLE_LIB_SUPPORT = n
 ENABLE_USE_FIRMWARE_FILE = n
 DISABLE_PM_SUPPORT = n
 DISABLE_MULTI_MSIX_VECTOR = n
+ENABLE_DOUBLE_VLAN = n
+ENABLE_PAGE_REUSE = n
+ENABLE_RX_PACKET_FRAGMENT = n
 
-obj-$(CONFIG_R8125) := r8125.o
-r8125-objs := r8125_n.o rtl_eeprom.o rtltool.o
+ifneq ($(KERNELRELEASE),)
+	obj-m := r8125.o
+	r8125-objs := r8125_n.o rtl_eeprom.o rtltool.o
+	ifeq ($(CONFIG_SOC_LAN), y)
+		EXTRA_CFLAGS += -DCONFIG_SOC_LAN
+	endif
+	ifeq ($(ENABLE_REALWOW_SUPPORT), y)
+		r8125-objs += r8125_realwow.o
+		EXTRA_CFLAGS += -DENABLE_REALWOW_SUPPORT
+	endif
+	ifeq ($(ENABLE_DASH_SUPPORT), y)
+		r8125-objs += r8125_dash.o
+		EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT
+	endif
+	ifeq ($(ENABLE_DASH_PRINTER_SUPPORT), y)
+		r8125-objs += r8125_dash.o
+		EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT -DENABLE_DASH_PRINTER_SUPPORT
+	endif
+	EXTRA_CFLAGS += -DCONFIG_R8125_NAPI
+	EXTRA_CFLAGS += -DCONFIG_R8125_VLAN
+	ifeq ($(CONFIG_DOWN_SPEED_100), y)
+		EXTRA_CFLAGS += -DCONFIG_DOWN_SPEED_100
+	endif
+	ifeq ($(CONFIG_ASPM), y)
+		EXTRA_CFLAGS += -DCONFIG_ASPM
+	endif
+	ifeq ($(ENABLE_S5WOL), y)
+		EXTRA_CFLAGS += -DENABLE_S5WOL
+	endif
+	ifeq ($(ENABLE_S5_KEEP_CURR_MAC), y)
+		EXTRA_CFLAGS += -DENABLE_S5_KEEP_CURR_MAC
+	endif
+	ifeq ($(ENABLE_EEE), y)
+		EXTRA_CFLAGS += -DENABLE_EEE
+	endif
+	ifeq ($(ENABLE_S0_MAGIC_PACKET), y)
+		EXTRA_CFLAGS += -DENABLE_S0_MAGIC_PACKET
+	endif
+	ifeq ($(ENABLE_TX_NO_CLOSE), y)
+		EXTRA_CFLAGS += -DENABLE_TX_NO_CLOSE
+	endif
+	ifeq ($(ENABLE_MULTIPLE_TX_QUEUE), y)
+		EXTRA_CFLAGS += -DENABLE_MULTIPLE_TX_QUEUE
+	endif
+	ifeq ($(ENABLE_PTP_SUPPORT), y)
+		r8125-objs += r8125_ptp.o
+		EXTRA_CFLAGS += -DENABLE_PTP_SUPPORT
+	endif
+	ifeq ($(ENABLE_PTP_MASTER_MODE), y)
+		EXTRA_CFLAGS += -DENABLE_PTP_MASTER_MODE
+	endif
+	ifeq ($(ENABLE_RSS_SUPPORT), y)
+		r8125-objs += r8125_rss.o
+		EXTRA_CFLAGS += -DENABLE_RSS_SUPPORT
+	endif
+	ifeq ($(ENABLE_LIB_SUPPORT), y)
+		r8125-objs += r8125_lib.o
+		EXTRA_CFLAGS += -DENABLE_LIB_SUPPORT
+	endif
+	ifeq ($(ENABLE_USE_FIRMWARE_FILE), y)
+		r8125-objs += r8125_firmware.o
+		EXTRA_CFLAGS += -DENABLE_USE_FIRMWARE_FILE
+	endif
+	ifeq ($(DISABLE_PM_SUPPORT), y)
+		EXTRA_CFLAGS += -DDISABLE_PM_SUPPORT
+	endif
+	ifeq ($(DISABLE_MULTI_MSIX_VECTOR), y)
+		EXTRA_CFLAGS += -DDISABLE_MULTI_MSIX_VECTOR
+	endif
+	ifeq ($(ENABLE_DOUBLE_VLAN), y)
+		EXTRA_CFLAGS += -DENABLE_DOUBLE_VLAN
+	endif
+	ifeq ($(ENABLE_PAGE_REUSE), y)
+		EXTRA_CFLAGS += -DENABLE_PAGE_REUSE
+	endif
+	ifeq ($(ENABLE_RX_PACKET_FRAGMENT), y)
+		EXTRA_CFLAGS += -DENABLE_RX_PACKET_FRAGMENT
+	endif
+else
+	BASEDIR := /lib/modules/$(shell uname -r)
+	KERNELDIR ?= $(BASEDIR)/build
+	PWD :=$(shell pwd)
+	DRIVERDIR := $(shell find $(BASEDIR)/kernel/drivers/net/ethernet -name realtek -type d)
+	ifeq ($(DRIVERDIR),)
+		DRIVERDIR := $(shell find $(BASEDIR)/kernel/drivers/net -name realtek -type d)
+	endif
+	ifeq ($(DRIVERDIR),)
+		DRIVERDIR := $(BASEDIR)/kernel/drivers/net
+	endif
+	RTKDIR := $(subst $(BASEDIR)/,,$(DRIVERDIR))
+
+	KERNEL_GCC_VERSION := $(shell cat /proc/version | sed -n 's/.*gcc version \([[:digit:]]\.[[:digit:]]\.[[:digit:]]\).*/\1/p')
+	CCVERSION = $(shell $(CC) -dumpversion)
+
+	KVER = $(shell uname -r)
+	KMAJ = $(shell echo $(KVER) | \
+	sed -e 's/^\([0-9][0-9]*\)\.[0-9][0-9]*\.[0-9][0-9]*.*/\1/')
+	KMIN = $(shell echo $(KVER) | \
+	sed -e 's/^[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*.*/\1/')
+	KREV = $(shell echo $(KVER) | \
+	sed -e 's/^[0-9][0-9]*\.[0-9][0-9]*\.\([0-9][0-9]*\).*/\1/')
+
+	kver_ge = $(shell \
+	echo test | awk '{if($(KMAJ) < $(1)) {print 0} else { \
+	if($(KMAJ) > $(1)) {print 1} else { \
+	if($(KMIN) < $(2)) {print 0} else { \
+	if($(KMIN) > $(2)) {print 1} else { \
+	if($(KREV) < $(3)) {print 0} else { print 1 } \
+	}}}}}' \
+	)
+
+.PHONY: all
+all: print_vars clean modules install
+
+print_vars:
+	@echo
+	@echo "CC: " $(CC)
+	@echo "CCVERSION: " $(CCVERSION)
+	@echo "KERNEL_GCC_VERSION: " $(KERNEL_GCC_VERSION)
+	@echo "KVER: " $(KVER)
+	@echo "KMAJ: " $(KMAJ)
+	@echo "KMIN: " $(KMIN)
+	@echo "KREV: " $(KREV)
+	@echo "BASEDIR: " $(BASEDIR)
+	@echo "DRIVERDIR: " $(DRIVERDIR)
+	@echo "PWD: " $(PWD)
+	@echo "RTKDIR: " $(RTKDIR)
+	@echo
+
+.PHONY:modules
+modules:
+#ifeq ($(call kver_ge,5,0,0),1)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+#else
+#	$(MAKE) -C $(KERNELDIR) SUBDIRS=$(PWD) modules
+#endif
+
+.PHONY:clean
+clean:
+#ifeq ($(call kver_ge,5,0,0),1)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) clean
+#else
+#	$(MAKE) -C $(KERNELDIR) SUBDIRS=$(PWD) clean
+#endif
+
+.PHONY:install
+install:
+#ifeq ($(call kver_ge,5,0,0),1)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) INSTALL_MOD_DIR=$(RTKDIR) modules_install
+#else
+#	$(MAKE) -C $(KERNELDIR) SUBDIRS=$(PWD) INSTALL_MOD_DIR=$(RTKDIR) modules_install
+#endif
 
-ifeq ($(CONFIG_SOC_LAN), y)
-	EXTRA_CFLAGS += -DCONFIG_SOC_LAN
-endif
-ifeq ($(ENABLE_REALWOW_SUPPORT), y)
-	r8125-objs += r8125_realwow.o
-	EXTRA_CFLAGS += -DENABLE_REALWOW_SUPPORT
-endif
-ifeq ($(ENABLE_DASH_SUPPORT), y)
-	r8125-objs += r8125_dash.o
-	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT
-endif
-ifeq ($(ENABLE_DASH_PRINTER_SUPPORT), y)
-	r8125-objs += r8125_dash.o
-	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT -DENABLE_DASH_PRINTER_SUPPORT
-endif
-EXTRA_CFLAGS += -DCONFIG_R8125_NAPI
-EXTRA_CFLAGS += -DCONFIG_R8125_VLAN
-ifeq ($(CONFIG_DOWN_SPEED_100), y)
-	EXTRA_CFLAGS += -DCONFIG_DOWN_SPEED_100
-endif
-ifeq ($(CONFIG_ASPM), y)
-	EXTRA_CFLAGS += -DCONFIG_ASPM
-endif
-ifeq ($(ENABLE_S5WOL), y)
-	EXTRA_CFLAGS += -DENABLE_S5WOL
-endif
-ifeq ($(ENABLE_S5_KEEP_CURR_MAC), y)
-	EXTRA_CFLAGS += -DENABLE_S5_KEEP_CURR_MAC
-endif
-ifeq ($(ENABLE_EEE), y)
-	EXTRA_CFLAGS += -DENABLE_EEE
-endif
-ifeq ($(ENABLE_S0_MAGIC_PACKET), y)
-	EXTRA_CFLAGS += -DENABLE_S0_MAGIC_PACKET
-endif
-ifeq ($(ENABLE_TX_NO_CLOSE), y)
-	EXTRA_CFLAGS += -DENABLE_TX_NO_CLOSE
-endif
-ifeq ($(ENABLE_MULTIPLE_TX_QUEUE), y)
-	EXTRA_CFLAGS += -DENABLE_MULTIPLE_TX_QUEUE
-endif
-ifeq ($(ENABLE_PTP_SUPPORT), y)
-	r8125-objs += r8125_ptp.o
-	EXTRA_CFLAGS += -DENABLE_PTP_SUPPORT
-endif
-ifeq ($(ENABLE_PTP_MASTER_MODE), y)
-	EXTRA_CFLAGS += -DENABLE_PTP_MASTER_MODE
-endif
-ifeq ($(ENABLE_RSS_SUPPORT), y)
-	r8125-objs += r8125_rss.o
-	EXTRA_CFLAGS += -DENABLE_RSS_SUPPORT
-endif
-ifeq ($(ENABLE_LIB_SUPPORT), y)
-	r8125-objs += r8125_lib.o
-	EXTRA_CFLAGS += -DENABLE_LIB_SUPPORT
-endif
-ifeq ($(ENABLE_USE_FIRMWARE_FILE), y)
-	r8125-objs += r8125_firmware.o
-	EXTRA_CFLAGS += -DENABLE_USE_FIRMWARE_FILE
-endif
-ifeq ($(DISABLE_PM_SUPPORT), y)
-	EXTRA_CFLAGS += -DDISABLE_PM_SUPPORT
-endif
-ifeq ($(DISABLE_MULTI_MSIX_VECTOR), y)
-	EXTRA_CFLAGS += -DDISABLE_MULTI_MSIX_VECTOR
 endif
--- a/drivers/net/ethernet/realtek/r8125/r8125.h
+++ b/drivers/net/ethernet/realtek/r8125/r8125.h
@@ -51,12 +51,35 @@
 typedef int netdev_tx_t;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0)
+static inline bool dev_page_is_reusable(const struct page *page)
+{
+        return likely(page_to_nid(page) == numa_mem_id() &&
+                      !page_is_pfmemalloc(page));
+}
+#endif
+
 /*
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)&& !defined(ENABLE_LIB_SUPPORT)
 #define RTL_USE_NEW_INTR_API
 #endif
 */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+#define dma_map_page_attrs(dev, page, offset, size, dir, attrs) \
+	dma_map_page(dev, page, offset, size, dir)
+#define dma_unmap_page_attrs(dev, page, size, dir, attrs) \
+	 dma_unmap_page(dev, page, size, dir)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+#define page_ref_inc(page) atomic_inc(&page->_count)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,216)
+#define page_ref_count(page) atomic_read(&page->_count)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,4,216)
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
 #define skb_transport_offset(skb) (skb->h.raw - skb->data)
 #endif
@@ -154,6 +177,14 @@ do { \
 #endif
 #endif
 
+#define RTL_BUILD_SKB_INTR(data, frag_size) build_skb(data, frag_size)
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,12,0)
+#undef RTL_BUILD_SKB_INTR
+#define RTL_BUILD_SKB_INTR(data, frag_size) napi_build_skb(data, frag_size)
+#endif
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
 #define eth_random_addr(addr) random_ether_addr(addr)
 #endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
@@ -206,7 +237,7 @@ do { \
 #define NETIF_F_RXFCS  0
 #endif
 
-#ifndef HAVE_FREE_NETDEV
+#if !defined(HAVE_FREE_NETDEV) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
 #define free_netdev(x)  kfree(x)
 #endif
 
@@ -334,7 +365,7 @@ do { \
 #ifndef NET_IP_ALIGN
 #define NET_IP_ALIGN        2
 #endif
-#define RTK_RX_ALIGN        8
+#define R8125_RX_ALIGN        NET_IP_ALIGN
 
 #ifdef CONFIG_R8125_NAPI
 #define NAPI_SUFFIX "-NAPI"
@@ -367,7 +398,7 @@ do { \
 #define RSS_SUFFIX ""
 #endif
 
-#define RTL8125_VERSION "9.009.00" NAPI_SUFFIX DASH_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
+#define RTL8125_VERSION "9.011.01" NAPI_SUFFIX DASH_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
 #define MODULENAME "r8125"
 #define PFX MODULENAME ": "
 
@@ -460,6 +491,8 @@ This is free software, and you are welco
 #define RTL8125_LINK_TIMEOUT    (1 * HZ)
 #define RTL8125_ESD_TIMEOUT (2 * HZ)
 
+#define rtl8125_rx_page_size(order) (PAGE_SIZE << order)
+
 #define MAX_NUM_TX_DESC 1024    /* Maximum number of Tx descriptor registers */
 #define MAX_NUM_RX_DESC 1024    /* Maximum number of Rx descriptor registers */
 
@@ -477,6 +510,11 @@ This is free software, and you are welco
 
 #define OCP_STD_PHY_BASE	0xa400
 
+//Channel Wait Count
+#define R8125_CHANNEL_WAIT_COUNT (20000)
+#define R8125_CHANNEL_WAIT_TIME (1)  // 1us
+#define R8125_CHANNEL_EXIT_DELAY_TIME (20)  //20us
+
 #ifdef ENABLE_LIB_SUPPORT
 #define R8125_MULTI_RX_Q(tp) 0
 #else
@@ -548,8 +586,11 @@ This is free software, and you are welco
 #ifndef ADVERTISED_2500baseX_Full
 #define ADVERTISED_2500baseX_Full  0x8000
 #endif
+#define RTK_ADVERTISED_5000baseX_Full  BIT(48)
 
 #define RTK_ADVERTISE_2500FULL  0x80
+#define RTK_ADVERTISE_5000FULL  0x100
+#define RTK_ADVERTISE_10000FULL  0x1000
 #define RTK_LPA_ADVERTISE_2500FULL  0x20
 #define RTK_LPA_ADVERTISE_5000FULL  0x40
 #define RTK_LPA_ADVERTISE_10000FULL  0x800
@@ -559,6 +600,9 @@ This is free software, and you are welco
 
 /* Tx NO CLOSE */
 #define MAX_TX_NO_CLOSE_DESC_PTR_V2 0x10000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2 0xFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V3 0x100000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3 0xFFFFFFFF
 #define TX_NO_CLOSE_SW_PTR_MASK_V2 0x1FFFF
 
 #ifndef ETH_MIN_MTU
@@ -578,6 +622,10 @@ This is free software, and you are welco
 #define READ_ONCE(var) (*((volatile typeof(var) *)(&(var))))
 #endif
 
+#ifndef SPEED_5000
+#define SPEED_5000		5000
+#endif
+
 /*****************************************************************************/
 
 //#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
@@ -628,7 +676,11 @@ typedef int *napi_budget;
 typedef struct napi_struct *napi_ptr;
 typedef int napi_budget;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
+#define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add_weight(ndev, &priv->napi, function, weight)
+#else
 #define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add(ndev, &priv->napi, function, weight)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
 #define RTL_NAPI_QUOTA(budget, ndev)            min(budget, budget)
 #define RTL_GET_PRIV(stuct_ptr, priv_struct)        container_of(stuct_ptr, priv_struct, stuct_ptr)
 #define RTL_GET_NETDEV(priv_ptr)            struct net_device *dev = priv_ptr->dev;
@@ -1224,12 +1276,15 @@ enum RTL8125_registers {
         IMR_V2_SET_REG_8125   = 0x0D0C,
         TDU_STA_8125       = 0x0D08,
         RDU_STA_8125       = 0x0D0A,
+        DOUBLE_VLAN_CONFIG = 0x1000,
         TX_NEW_CTRL        = 0x203E,
         TNPDS_Q1_LOW_8125  = 0x2100,
         PLA_TXQ0_IDLE_CREDIT = 0x2500,
         PLA_TXQ1_IDLE_CREDIT = 0x2504,
         SW_TAIL_PTR0_8125  = 0x2800,
         HW_CLO_PTR0_8125   = 0x2802,
+        SW_TAIL_PTR0_8126  = 0x2800,
+        HW_CLO_PTR0_8126   = 0x2800,
         RDSAR_Q1_LOW_8125  = 0x4000,
         RSS_CTRL_8125      = 0x4500,
         Q_NUM_CTRL_8125    = 0x4800,
@@ -1377,6 +1432,7 @@ enum RTL8125_register_content {
 
         /* rtl8125_PHYstatus */
         PowerSaveStatus = 0x80,
+        _5000bpsF = 0x1000,
         _2500bpsF = 0x400,
         TxFlowCtrl = 0x40,
         RxFlowCtrl = 0x20,
@@ -1622,7 +1678,17 @@ enum bits {
         BIT_31 = (1 << 31)
 };
 
-enum effuse {
+#define RTL8125_CP_NUM 4
+#define RTL8125_MAX_SUPPORT_cp_len 110
+
+enum rtl8125_cp_status {
+        rtl8125_cp_normal = 0,
+        rtl8125_cp_short,
+        rtl8125_cp_open,
+        rtl8125_cp_unknown
+};
+
+enum efuse {
         EFUSE_NOT_SUPPORT = 0,
         EFUSE_SUPPORT_V1,
         EFUSE_SUPPORT_V2,
@@ -1760,6 +1826,7 @@ struct rtl8125_tx_ring {
         u32 num_tx_desc; /* Number of Tx descriptor registers */
         struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
         dma_addr_t TxPhyAddr;
+        u32 TxDescAllocSize;
         struct ring_info tx_skb[MAX_NUM_TX_DESC]; /* Tx data buffers */
 
         u32 NextHwDesCloPtr;
@@ -1771,6 +1838,14 @@ struct rtl8125_tx_ring {
         u16 tdsar_reg; /* Transmit Descriptor Start Address */
 };
 
+struct rtl8125_rx_buffer {
+        struct page *page;
+        u32 page_offset;
+        dma_addr_t dma;
+        void* data;
+        struct sk_buff *skb;
+};
+
 struct rtl8125_rx_ring {
         void* priv;
         u32 index;
@@ -1778,9 +1853,15 @@ struct rtl8125_rx_ring {
         u32 dirty_rx;
         u32 num_rx_desc; /* Number of Rx descriptor registers */
         struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        u32 RxDescAllocSize;
         u64 RxDescPhyAddr[MAX_NUM_RX_DESC]; /* Rx desc physical address*/
         dma_addr_t RxPhyAddr;
+#ifdef ENABLE_PAGE_REUSE
+        struct rtl8125_rx_buffer rx_buffer[MAX_NUM_RX_DESC];
+        u16 rx_offset;
+#else
         struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+#endif //ENABLE_PAGE_REUSE
 
         u16 rdsar_reg; /* Receive Descriptor Start Address */
 };
@@ -2048,6 +2129,11 @@ struct rtl8125_private {
         //struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
         //struct ring_info tx_skb[MAX_NUM_TX_DESC];   /* Tx data buffers */
         unsigned rx_buf_sz;
+#ifdef ENABLE_PAGE_REUSE
+        unsigned rx_buf_page_order;
+        unsigned rx_buf_page_size;
+        u32 page_reuse_fail_cnt;
+#endif //ENABLE_PAGE_REUSE
         u16 HwSuppNumTxQueues;
         u16 HwSuppNumRxQueues;
         unsigned int num_tx_rings;
@@ -2065,6 +2151,7 @@ struct rtl8125_private {
         unsigned int esd_flag;
         unsigned int pci_cfg_is_read;
         unsigned int rtl8125_rx_config;
+        u16 rms;
         u16 cp_cmd;
         u32 intr_mask;
         u32 timer_intr_mask;
@@ -2087,13 +2174,14 @@ struct rtl8125_private {
         u8  autoneg;
         u8  duplex;
         u32 speed;
-        u32 advertising;
+        u64 advertising;
         enum rtl8125_fc_mode fcpause;
+        u32 HwSuppMaxPhyLinkSpeed;
         u16 eeprom_len;
         u16 cur_page;
         u32 bios_setting;
 
-        int (*set_speed)(struct net_device *, u8 autoneg, u32 speed, u8 duplex, u32 adv);
+        int (*set_speed)(struct net_device *, u8 autoneg, u32 speed, u8 duplex, u64 adv);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
         void (*get_settings)(struct net_device *, struct ethtool_cmd *);
 #else
@@ -2178,6 +2266,7 @@ struct rtl8125_private {
 
         u32 HwPcieSNOffset;
 
+        u32 MaxTxDescPtrMask;
         u8 HwSuppTxNoCloseVer;
         u8 EnableTxNoClose;
 
@@ -2393,6 +2482,7 @@ enum mcfg {
         CFG_METHOD_5,
         CFG_METHOD_6,
         CFG_METHOD_7,
+        CFG_METHOD_8,
         CFG_METHOD_DEFAULT,
         CFG_METHOD_MAX
 };
@@ -2427,6 +2517,7 @@ enum mcfg {
 #define NIC_RAMCODE_VERSION_CFG_METHOD_3 (0x0b33)
 #define NIC_RAMCODE_VERSION_CFG_METHOD_4 (0x0b17)
 #define NIC_RAMCODE_VERSION_CFG_METHOD_5 (0x0b74)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_8 (0x0023)
 
 //hwoptimize
 #define HW_PATCH_SOC_LAN (BIT_0)
@@ -2515,6 +2606,8 @@ int rtl8125_init_ring(struct net_device
 void rtl8125_hw_set_rx_packet_filter(struct net_device *dev);
 void rtl8125_enable_hw_linkchg_interrupt(struct rtl8125_private *tp);
 int rtl8125_dump_tally_counter(struct rtl8125_private *tp, dma_addr_t paddr);
+void rtl8125_enable_napi(struct rtl8125_private *tp);
+void _rtl8125_wait_for_quiescence(struct net_device *dev);
 
 #ifndef ENABLE_LIB_SUPPORT
 static inline void rtl8125_lib_reset_prepare(struct rtl8125_private *tp) { }
@@ -2526,6 +2619,10 @@ static inline void rtl8125_lib_reset_com
 #define HW_SUPPORT_D0_SPEED_UP(_M)        ((_M)->HwSuppD0SpeedUpVer > 0)
 #define HW_SUPPORT_MAC_MCU(_M)        ((_M)->HwSuppMacMcuVer > 0)
 
+#define HW_SUPP_PHY_LINK_SPEED_GIGA(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 1000)
+#define HW_SUPP_PHY_LINK_SPEED_2500M(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 2500)
+#define HW_SUPP_PHY_LINK_SPEED_5000M(_M)        ((_M)->HwSuppMaxPhyLinkSpeed >= 5000)
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
 #define netdev_mc_count(dev) ((dev)->mc_count)
 #define netdev_mc_empty(dev) (netdev_mc_count(dev) == 0)
--- a/drivers/net/ethernet/realtek/r8125/r8125_n.c
+++ b/drivers/net/ethernet/realtek/r8125/r8125_n.c
@@ -90,10 +90,9 @@
 #include <linux/seq_file.h>
 #endif
 
-/* #include <asm/system_info.h> */
-
 #define FIRMWARE_8125A_3	"rtl_nic/rtl8125a-3.fw"
 #define FIRMWARE_8125B_2	"rtl_nic/rtl8125b-2.fw"
+#define FIRMWARE_8126A_1	"rtl_nic/rtl8126a-1.fw"
 
 /* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
    The RTL chips use a 64 element hash table based on the Ethernet CRC. */
@@ -110,6 +109,7 @@ static const struct {
         [CFG_METHOD_5] = {"RTL8125B",		FIRMWARE_8125B_2},
         [CFG_METHOD_6] = {"RTL8168KB",		FIRMWARE_8125A_3},
         [CFG_METHOD_7] = {"RTL8168KB",		FIRMWARE_8125B_2},
+        [CFG_METHOD_8] = {"RTL8126A",		FIRMWARE_8126A_1},
         [CFG_METHOD_DEFAULT] = {"Unknown",                  },
 };
 
@@ -159,6 +159,12 @@ static const struct {
         0xff7e5880,
         Jumbo_Frame_9k),
 
+        _R("RTL8126A",
+        CFG_METHOD_8,
+        BIT_30 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
         _R("Unknown",
         CFG_METHOD_DEFAULT,
         (RX_DMA_BURST << RxCfgDMAShift),
@@ -176,22 +182,22 @@ static struct pci_device_id rtl8125_pci_
         { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8125), },
         { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8162), },
         { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x3000), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8126), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x5000), },
         {0,},
 };
 
 MODULE_DEVICE_TABLE(pci, rtl8125_pci_tbl);
 
-static int rx_copybreak = 0;
 static int use_dac = 1;
 static int timer_count = 0x2600;
 static int timer_count_v2 = (0x2600 / 0x100);
-/* static int dev_num = 0; */
 
 static struct {
         u32 msg_enable;
 } debug = { -1 };
 
-static unsigned int speed_mode = SPEED_2500;
+static unsigned int speed_mode = SPEED_5000;
 static unsigned int duplex_mode = DUPLEX_FULL;
 static unsigned int autoneg_mode = AUTONEG_ENABLE;
 static unsigned int advertising_mode =  ADVERTISED_10baseT_Half |
@@ -247,6 +253,12 @@ static int disable_pm_support = 1;
 static int disable_pm_support = 0;
 #endif
 
+#ifdef ENABLE_DOUBLE_VLAN
+static int enable_double_vlan = 1;
+#else
+static int enable_double_vlan = 0;
+#endif
+
 MODULE_AUTHOR("Realtek and the Linux r8125 crew <netdev@vger.kernel.org>");
 MODULE_DESCRIPTION("Realtek RTL8125 2.5Gigabit Ethernet driver");
 
@@ -271,9 +283,6 @@ MODULE_PARM_DESC(s5wol, "Enable Shutdown
 module_param(s5_keep_curr_mac, int, 0);
 MODULE_PARM_DESC(s5_keep_curr_mac, "Enable Shutdown Keep Current MAC Address.");
 
-module_param(rx_copybreak, int, 0);
-MODULE_PARM_DESC(rx_copybreak, "Copy breakpoint for copy-only-tiny-frames");
-
 module_param(use_dac, int, 0);
 MODULE_PARM_DESC(use_dac, "Enable PCI DAC. Unsafe on 32 bit PCI slot.");
 
@@ -298,6 +307,9 @@ MODULE_PARM_DESC(enable_ptp_master_mode,
 module_param(disable_pm_support, int, 0);
 MODULE_PARM_DESC(disable_pm_support, "Disable PM support.");
 
+module_param(enable_double_vlan, int, 0);
+MODULE_PARM_DESC(enable_double_vlan, "Enable Double VLAN.");
+
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 module_param_named(debug, debug.msg_enable, int, 0);
 MODULE_PARM_DESC(debug, "Debug verbosity level (0=none, ..., 16=all)");
@@ -343,7 +355,6 @@ static void rtl8125_tx_timeout(struct ne
 #else
 static void rtl8125_tx_timeout(struct net_device *dev);
 #endif
-static struct net_device_stats *rtl8125_get_stats(struct net_device *dev);
 static int rtl8125_rx_interrupt(struct net_device *, struct rtl8125_private *, struct rtl8125_rx_ring *, napi_budget);
 static int rtl8125_tx_interrupt(struct rtl8125_tx_ring *ring, int budget);
 static int rtl8125_tx_interrupt_with_vector(struct rtl8125_private *tp, const int message_id, int budget);
@@ -361,7 +372,7 @@ static u32 mdio_direct_read_phy_ocp(stru
 static u16 rtl8125_get_hw_phy_mcu_code_ver(struct rtl8125_private *tp);
 static void rtl8125_phy_power_up(struct net_device *dev);
 static void rtl8125_phy_power_down(struct net_device *dev);
-static int rtl8125_set_speed(struct net_device *dev, u8 autoneg, u32 speed, u8 duplex, u32 adv);
+static int rtl8125_set_speed(struct net_device *dev, u8 autoneg, u32 speed, u8 duplex, u64 adv);
 static bool rtl8125_set_phy_mcu_patch_request(struct rtl8125_private *tp);
 static bool rtl8125_clear_phy_mcu_patch_request(struct rtl8125_private *tp);
 
@@ -518,7 +529,7 @@ static inline void eth_copy_and_sum (str
                                      const unsigned char *src,
                                      int len, int base)
 {
-        memcpy (dest->data, src, len);
+        skb_copy_to_linear_data(dest, src, len);
 }
 #endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
 
@@ -703,6 +714,158 @@ int rtl8125_dump_tally_counter(struct rt
         return retval;
 }
 
+static u32 rtl8125_convert_link_speed(u16 status)
+{
+        u32 speed = SPEED_UNKNOWN;
+
+        if (status & LinkStatus) {
+                if (status & _5000bpsF)
+                        speed = SPEED_5000;
+                else if (status & _2500bpsF)
+                        speed = SPEED_2500;
+                else if (status & _1000bpsF)
+                        speed = SPEED_1000;
+                else if (status & _100bps)
+                        speed = SPEED_100;
+                else if (status & _10bps)
+                        speed = SPEED_10;
+        }
+
+        return speed;
+}
+
+static void rtl8125_get_cp_len(struct rtl8125_private *tp,
+                               u16 cp_len[RTL8125_CP_NUM])
+{
+        int i;
+        int count;
+        u16 status;
+        u16 tmp_cp_len = 0;
+
+        status = RTL_R16(tp, PHYstatus);
+        if (status & LinkStatus) {
+                if (status & _10bps) {
+                        tmp_cp_len = 0;
+                        goto no_cpdr;
+                } else if (status & _1000bpsF) {
+                        rtl8125_mdio_write(tp, 0x1f, 0x0a88);
+                        tmp_cp_len = rtl8125_mdio_read(tp, 0x10);
+                        goto no_cpdr;
+                } else if (status & _2500bpsF) {
+                        switch (tp->mcfg) {
+                        case CFG_METHOD_2:
+                        case CFG_METHOD_3:
+                        case CFG_METHOD_6:
+                                rtl8125_mdio_write(tp, 0x1f, 0x0ac5);
+                                tmp_cp_len = rtl8125_mdio_read(tp, 0x14) >> 4;
+                                break;
+                        default:
+                                rtl8125_mdio_write(tp, 0x1f, 0x0acb);
+                                tmp_cp_len = rtl8125_mdio_read(tp, 0x15) >> 2;
+                                break;
+                        }
+                        goto no_cpdr;
+                }
+        }
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0a42);
+        rtl8125_mdio_write(tp, 0x11, 0x0000);
+        rtl8125_set_eth_phy_bit(tp, 0x11, 0xf0);
+        rtl8125_set_eth_phy_bit(tp, 0x11, 0x01);
+
+        count = 0;
+        while (!(rtl8125_mdio_read(tp, 0x11) & BIT_15) &&
+               (count++ < 200))
+                msleep(100);
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0a43);
+        for (i=0; i<RTL8125_CP_NUM; i++) {
+                u16 val;
+                rtl8125_mdio_write(tp, 0x13, 0x8029 + 4 * i);
+                val = rtl8125_mdio_read(tp, 0x14);
+                tmp_cp_len = ((val & 0x3fff) / 80) & 0xff;
+                if (tmp_cp_len > 200)
+                        tmp_cp_len = 0;
+                cp_len[i] = tmp_cp_len;
+        }
+
+        goto exit;
+
+no_cpdr:
+        tmp_cp_len &= 0xff;
+        for (i=0; i<RTL8125_CP_NUM; i++)
+                cp_len[i] = tmp_cp_len;
+
+exit:
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+
+        for (i=0; i<RTL8125_CP_NUM; i++)
+                if (cp_len[i] > RTL8125_MAX_SUPPORT_cp_len)
+                        cp_len[i] = RTL8125_MAX_SUPPORT_cp_len;
+
+        return;
+}
+
+static int _rtl8125_get_cp_status(u16 val)
+{
+        switch (val) {
+        case 0x0060:
+                return rtl8125_cp_normal;
+        case 0x0042:
+        case 0x0048:
+                return rtl8125_cp_open;
+        case 0x0044:
+        case 0x0050:
+                return rtl8125_cp_short;
+        default:
+                return rtl8125_cp_normal;
+        }
+}
+
+static int rtl8125_get_cp_status(struct rtl8125_private *tp, u8 pair_num)
+{
+        u16 val;
+        int cp_status = rtl8125_cp_unknown;
+
+        if (pair_num > 3)
+                goto exit;
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0a43);
+        rtl8125_mdio_write(tp, 0x13, 0x8027 + 4 * pair_num);
+        val = rtl8125_mdio_read(tp, 0x14);
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+
+        cp_status = _rtl8125_get_cp_status(val);
+
+exit:
+        return cp_status;
+}
+
+static const char * rtl8125_get_cp_status_string(int cp_status)
+{
+        switch(cp_status) {
+        case rtl8125_cp_normal:
+                return "normal";
+        case rtl8125_cp_short:
+                return "short";
+        case rtl8125_cp_open:
+                return "open";
+        default:
+                return "unknown";
+        }
+}
+
+static void rtl8125_get_cp(struct rtl8125_private *tp,
+                           u16 cp_len[RTL8125_CP_NUM],
+                           int cp_status[RTL8125_CP_NUM])
+{
+        int i;
+
+        rtl8125_get_cp_len(tp, cp_len);
+        for (i =0; i<RTL8125_CP_NUM; i++)
+                cp_status[i] = rtl8125_get_cp_status(tp, i);
+}
+
 #ifdef ENABLE_R8125_PROCFS
 /****************************************************************************
 *   -----------------------------PROCFS STUFF-------------------------
@@ -744,6 +907,11 @@ static int proc_get_driver_variable(stru
         seq_printf(m, "cur_tx1\t0x%x\n", tp->tx_ring[1].cur_tx);
         seq_printf(m, "dirty_tx1\t0x%x\n", tp->tx_ring[1].dirty_tx);
         seq_printf(m, "rx_buf_sz\t0x%x\n", tp->rx_buf_sz);
+#ifdef ENABLE_PAGE_REUSE
+        seq_printf(m, "rx_buf_page_order\t0x%x\n", tp->rx_buf_page_order);
+        seq_printf(m, "rx_buf_page_size\t0x%x\n", tp->rx_buf_page_size);
+        seq_printf(m, "page_reuse_fail_cnt\t0x%x\n", tp->page_reuse_fail_cnt);
+#endif //ENABLE_PAGE_REUSE
         seq_printf(m, "esd_flag\t0x%x\n", tp->esd_flag);
         seq_printf(m, "pci_cfg_is_read\t0x%x\n", tp->pci_cfg_is_read);
         seq_printf(m, "rtl8125_rx_config\t0x%x\n", tp->rtl8125_rx_config);
@@ -757,7 +925,7 @@ static int proc_get_driver_variable(stru
         seq_printf(m, "autoneg\t0x%x\n", tp->autoneg);
         seq_printf(m, "duplex\t0x%x\n", tp->duplex);
         seq_printf(m, "speed\t%d\n", tp->speed);
-        seq_printf(m, "advertising\t0x%x\n", tp->advertising);
+        seq_printf(m, "advertising\t0x%llx\n", tp->advertising);
         seq_printf(m, "eeprom_len\t0x%x\n", tp->eeprom_len);
         seq_printf(m, "cur_page\t0x%x\n", tp->cur_page);
         seq_printf(m, "bios_setting\t0x%x\n", tp->bios_setting);
@@ -803,6 +971,8 @@ static int proc_get_driver_variable(stru
         seq_printf(m, "hwoptimize\t0x%lx\n", hwoptimize);
         seq_printf(m, "proc_init_num\t0x%x\n", proc_init_num);
         seq_printf(m, "s0_magic_packet\t0x%x\n", s0_magic_packet);
+        seq_printf(m, "disable_pm_support\t0x%x\n", disable_pm_support);
+        seq_printf(m, "enable_double_vlan\t0x%x\n", enable_double_vlan);
         seq_printf(m, "HwSuppMagicPktVer\t0x%x\n", tp->HwSuppMagicPktVer);
         seq_printf(m, "HwSuppLinkChgWakeUpVer\t0x%x\n", tp->HwSuppLinkChgWakeUpVer);
         seq_printf(m, "HwSuppD0SpeedUpVer\t0x%x\n", tp->HwSuppD0SpeedUpVer);
@@ -1074,8 +1244,7 @@ static int proc_get_temperature(struct s
                 seq_puts(m, "\nChip Temperature\n");
                 break;
         default:
-                seq_puts(m, "\nThis Chip Does Not Support Dump Temperature\n");
-                break;
+                return -EOPNOTSUPP;
         }
 
         rtnl_lock();
@@ -1098,6 +1267,46 @@ static int proc_get_temperature(struct s
         seq_putc(m, '\n');
         return 0;
 }
+
+static int proc_get_cable_info(struct seq_file *m, void *v)
+{
+        int i;
+        u16 status;
+        int cp_status[RTL8125_CP_NUM];
+        u16 cp_len[RTL8125_CP_NUM] = {0};
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2 ... CFG_METHOD_7:
+                /* support */
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        rtnl_lock();
+
+        status = RTL_R16(tp, PHYstatus);
+        if (status & LinkStatus)
+                seq_printf(m, "\nlink speed:%d",
+                           rtl8125_convert_link_speed(status));
+        else
+                seq_puts(m, "\nlink status:off");
+
+        rtl8125_get_cp(tp, cp_len, cp_status);
+
+        rtnl_unlock();
+
+        seq_puts(m, "\npair\tlength\tstaus\n");
+
+        for (i =0; i<RTL8125_CP_NUM; i++)
+                seq_printf(m, "%d-%d\t%d\t%s\n", i+1, i+2, cp_len[i],
+                           rtl8125_get_cp_status_string(cp_status[i]));
+
+        seq_putc(m, '\n');
+        return 0;
+}
 #else
 
 static int proc_get_driver_variable(char *page, char **start,
@@ -1138,6 +1347,11 @@ static int proc_get_driver_variable(char
                         "cur_tx1\t0x%x\n"
                         "dirty_tx1\t0x%x\n"
                         "rx_buf_sz\t0x%x\n"
+#ifdef ENABLE_PAGE_REUSE
+                        "rx_buf_page_order\t0x%x\n"
+                        "rx_buf_page_size\t0x%x\n"
+                        "page_reuse_fail_cnt\t0x%x\n"
+#endif //ENABLE_PAGE_REUSE
                         "esd_flag\t0x%x\n"
                         "pci_cfg_is_read\t0x%x\n"
                         "rtl8125_rx_config\t0x%x\n"
@@ -1151,7 +1365,7 @@ static int proc_get_driver_variable(char
                         "autoneg\t0x%x\n"
                         "duplex\t0x%x\n"
                         "speed\t%d\n"
-                        "advertising\t0x%x\n"
+                        "advertising\t0x%llx\n"
                         "eeprom_len\t0x%x\n"
                         "cur_page\t0x%x\n"
                         "bios_setting\t0x%x\n"
@@ -1197,6 +1411,8 @@ static int proc_get_driver_variable(char
                         "hwoptimize\t0x%lx\n"
                         "proc_init_num\t0x%x\n"
                         "s0_magic_packet\t0x%x\n"
+                        "disable_pm_support\t0x%x\n"
+                        "enable_double_vlan\t0x%x\n"
                         "HwSuppMagicPktVer\t0x%x\n"
                         "HwSuppLinkChgWakeUpVer\t0x%x\n"
                         "HwSuppD0SpeedUpVer\t0x%x\n"
@@ -1254,6 +1470,11 @@ static int proc_get_driver_variable(char
                         tp->tx_ring[1].cur_tx,
                         tp->tx_ring[1].dirty_tx,
                         tp->rx_buf_sz,
+#ifdef ENABLE_PAGE_REUSE
+                        tp->rx_buf_page_order,
+                        tp->rx_buf_page_size,
+                        tp->page_reuse_fail_cnt,
+#endif //ENABLE_PAGE_REUSE
                         tp->esd_flag,
                         tp->pci_cfg_is_read,
                         tp->rtl8125_rx_config,
@@ -1313,6 +1534,8 @@ static int proc_get_driver_variable(char
                         hwoptimize,
                         proc_init_num,
                         s0_magic_packet,
+                        disable_pm_support,
+                        enable_double_vlan,
                         tp->HwSuppMagicPktVer,
                         tp->HwSuppLinkChgWakeUpVer,
                         tp->HwSuppD0SpeedUpVer,
@@ -1697,9 +1920,7 @@ static int proc_get_temperature(char *pa
                                 "\nChip Temperature\n");
                 break;
         default:
-                len += snprintf(page + len, count - len,
-                                "\nThis Chip Does Not Support Dump Temperature\n");
-                break;
+                return -EOPNOTSUPP;
         }
 
         rtnl_lock();
@@ -1733,6 +1954,56 @@ static int proc_get_temperature(char *pa
         *eof = 1;
         return len;
 }
+
+static int proc_get_cable_info(char *page, char **start,
+                               off_t offset, int count,
+                               int *eof, void *data)
+{
+        int i;
+        u16 status;
+        int len = 0;
+        struct net_device *dev = data;
+        int cp_status[RTL8125_CP_NUM] = {0};
+        u16 cp_len[RTL8125_CP_NUM] = {0};
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2 ... CFG_METHOD_7:
+                /* support */
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        rtnl_lock();
+
+        status = RTL_R16(tp, PHYstatus);
+        if (status & LinkStatus)
+                len += snprintf(page + len, count - len,
+                                "\nlink speed:%d",
+                                rtl8125_convert_link_speed(status));
+        else
+                len += snprintf(page + len, count - len,
+                                "\nlink status:off");
+
+        rtl8125_get_cp(tp, cp_len, cp_status);
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len,
+                        "\npair\tlength\tstaus\n");
+
+        for (i =0; i<RTL8125_CP_NUM; i++)
+                len += snprintf(page + len, count - len,
+                                "%d-%d\t%d\t%s\n",
+                                i+1, i+2, cp_len[i],
+                                rtl8125_get_cp_status_string(cp_status[i]));
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
 #endif
 static void rtl8125_proc_module_init(void)
 {
@@ -1801,6 +2072,7 @@ static const struct rtl8125_proc_file rt
         { "ext_regs", &proc_get_extended_registers },
         { "pci_regs", &proc_get_pci_registers },
         { "temp", &proc_get_temperature },
+        { "cdt", &proc_get_cable_info },
         { "", NULL }
 };
 
@@ -1924,8 +2196,8 @@ static void mdio_real_direct_write_phy_o
         data32 |= OCPR_Write | value;
 
         RTL_W32(tp, PHYOCP, data32);
-        for (i = 0; i < 100; i++) {
-                udelay(1);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
 
                 if (!(RTL_R32(tp, PHYOCP) & OCPR_Flag))
                         break;
@@ -2014,8 +2286,8 @@ static u32 mdio_real_direct_read_phy_ocp
         data32 <<= OCPR_Addr_Reg_shift;
 
         RTL_W32(tp, PHYOCP, data32);
-        for (i = 0; i < 100; i++) {
-                udelay(1);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
 
                 if (RTL_R32(tp, PHYOCP) & OCPR_Flag)
                         break;
@@ -2277,15 +2549,13 @@ void rtl8125_oob_mutex_lock(struct rtl81
         switch (tp->mcfg) {
         case CFG_METHOD_2:
         case CFG_METHOD_3:
-        case CFG_METHOD_4:
-        case CFG_METHOD_5:
         case CFG_METHOD_6:
-        case CFG_METHOD_7:
-        default:
                 ocp_reg_mutex_oob = 0x110;
                 ocp_reg_mutex_ib = 0x114;
                 ocp_reg_mutex_prio = 0x11C;
                 break;
+        default:
+                return;
         }
 
         rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, BIT_0);
@@ -2328,15 +2598,13 @@ void rtl8125_oob_mutex_unlock(struct rtl
         switch (tp->mcfg) {
         case CFG_METHOD_2:
         case CFG_METHOD_3:
-        case CFG_METHOD_4:
-        case CFG_METHOD_5:
         case CFG_METHOD_6:
-        case CFG_METHOD_7:
-        default:
                 ocp_reg_mutex_oob = 0x110;
                 ocp_reg_mutex_ib = 0x114;
                 ocp_reg_mutex_prio = 0x11C;
                 break;
+        default:
+                return;
         }
 
         rtl8125_ocp_write(tp, ocp_reg_mutex_prio, 1, BIT_0);
@@ -2426,51 +2694,65 @@ static void rtl8125_dash2_disable_txrx(s
         }
 }
 
-static void rtl8125_driver_start(struct rtl8125_private *tp)
+static int rtl8125_wait_dash_fw_ready(struct rtl8125_private *tp)
 {
-        if (!tp->DASH)
-                return;
+        int rc = -1;
+        int timeout;
 
-        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
-                int timeout;
-                u32 tmp_value;
+        if (HW_DASH_SUPPORT_TYPE_2(tp) == FALSE &&
+            HW_DASH_SUPPORT_TYPE_3(tp) == FALSE)
+                goto out;
 
-                rtl8125_ocp_write(tp, 0x180, 1, OOB_CMD_DRIVER_START);
-                tmp_value = rtl8125_ocp_read(tp, 0x30, 1);
-                tmp_value |= BIT_0;
-                rtl8125_ocp_write(tp, 0x30, 1, tmp_value);
+        if (!tp->DASH)
+                goto out;
 
-                for (timeout = 0; timeout < 10; timeout++) {
-                        mdelay(10);
-                        if (rtl8125_ocp_read(tp, 0x124, 1) & BIT_0)
-                                break;
+        for (timeout = 0; timeout < 10; timeout++) {
+                mdelay(10);
+                if (rtl8125_ocp_read(tp, 0x124, 1) & BIT_0) {
+                        rc = 1;
+                        goto out;
                 }
         }
+
+        rc = 0;
+
+out:
+        return rc;
 }
 
-static void rtl8125_driver_stop(struct rtl8125_private *tp)
+static void rtl8125_driver_start(struct rtl8125_private *tp)
 {
-        if (!tp->DASH)
+        u32 tmp_value;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) == FALSE &&
+            HW_DASH_SUPPORT_TYPE_3(tp) == FALSE)
                 return;
 
-        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
-                struct net_device *dev = tp->dev;
-                int timeout;
-                u32 tmp_value;
+        rtl8125_ocp_write(tp, 0x180, 1, OOB_CMD_DRIVER_START);
+        tmp_value = rtl8125_ocp_read(tp, 0x30, 1);
+        tmp_value |= BIT_0;
+        rtl8125_ocp_write(tp, 0x30, 1, tmp_value);
 
-                rtl8125_dash2_disable_txrx(dev);
+        rtl8125_wait_dash_fw_ready(tp);
+}
+
+static void rtl8125_driver_stop(struct rtl8125_private *tp)
+{
+        u32 tmp_value;
+        struct net_device *dev = tp->dev;
 
-                rtl8125_ocp_write(tp, 0x180, 1, OOB_CMD_DRIVER_STOP);
-                tmp_value = rtl8125_ocp_read(tp, 0x30, 1);
-                tmp_value |= BIT_0;
-                rtl8125_ocp_write(tp, 0x30, 1, tmp_value);
+        if (HW_DASH_SUPPORT_TYPE_2(tp) == FALSE &&
+            HW_DASH_SUPPORT_TYPE_3(tp) == FALSE)
+                return;
 
-                for (timeout = 0; timeout < 10; timeout++) {
-                        mdelay(10);
-                        if (!(rtl8125_ocp_read(tp, 0x124, 1) & BIT_0))
-                                break;
-                }
-        }
+        rtl8125_dash2_disable_txrx(dev);
+
+        rtl8125_ocp_write(tp, 0x180, 1, OOB_CMD_DRIVER_STOP);
+        tmp_value = rtl8125_ocp_read(tp, 0x30, 1);
+        tmp_value |= BIT_0;
+        rtl8125_ocp_write(tp, 0x30, 1, tmp_value);
+
+        rtl8125_wait_dash_fw_ready(tp);
 }
 
 void rtl8125_ephy_write(struct rtl8125_private *tp, int RegAddr, int value)
@@ -2482,15 +2764,15 @@ void rtl8125_ephy_write(struct rtl8125_p
                 (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift |
                 (value & EPHYAR_Data_Mask));
 
-        for (i = 0; i < 10; i++) {
-                udelay(100);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
 
                 /* Check if the RTL8125 has completed EPHY write */
                 if (!(RTL_R32(tp, EPHYAR) & EPHYAR_Flag))
                         break;
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 }
 
 u16 rtl8125_ephy_read(struct rtl8125_private *tp, int RegAddr)
@@ -2501,8 +2783,8 @@ u16 rtl8125_ephy_read(struct rtl8125_pri
         RTL_W32(tp, EPHYAR,
                 EPHYAR_Read | (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift);
 
-        for (i = 0; i < 10; i++) {
-                udelay(100);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
 
                 /* Check if the RTL8125 has completed EPHY read */
                 if (RTL_R32(tp, EPHYAR) & EPHYAR_Flag) {
@@ -2511,7 +2793,7 @@ u16 rtl8125_ephy_read(struct rtl8125_pri
                 }
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 
         return value;
 }
@@ -2551,7 +2833,7 @@ rtl8125_csi_other_fun_read(struct rtl812
 {
         u32 cmd;
         int i;
-        u32 value = 0;
+        u32 value = 0xffffffff;
 
         cmd = CSIAR_Read | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
 
@@ -2559,14 +2841,14 @@ rtl8125_csi_other_fun_read(struct rtl812
                 multi_fun_sel_bit = 0;
 
         if (multi_fun_sel_bit > 7)
-                return 0xffffffff;
+                goto exit;
 
         cmd |= multi_fun_sel_bit << 16;
 
         RTL_W32(tp, CSIAR, cmd);
 
-        for (i = 0; i < 10; i++) {
-                udelay(100);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
 
                 /* Check if the RTL8125 has completed CSI read */
                 if (RTL_R32(tp, CSIAR) & CSIAR_Flag) {
@@ -2575,8 +2857,9 @@ rtl8125_csi_other_fun_read(struct rtl812
                 }
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 
+exit:
         return value;
 }
 
@@ -2601,15 +2884,15 @@ rtl8125_csi_other_fun_write(struct rtl81
 
         RTL_W32(tp, CSIAR, cmd);
 
-        for (i = 0; i < 10; i++) {
-                udelay(100);
+        for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                udelay(R8125_CHANNEL_WAIT_TIME);
 
                 /* Check if the RTL8125 has completed CSI write */
                 if (!(RTL_R32(tp, CSIAR) & CSIAR_Flag))
                         break;
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 }
 
 static u32
@@ -2652,12 +2935,12 @@ rtl8125_csi_fun0_read_byte(struct rtl812
 
                 RegAlignAddr = addr & ~(0x3);
                 ShiftByte = addr & (0x3);
-                TmpUlong = rtl8125_csi_other_fun_read(tp, 0, addr);
+                TmpUlong = rtl8125_csi_other_fun_read(tp, 0, RegAlignAddr);
                 TmpUlong >>= (8*ShiftByte);
                 RetVal = (u8)TmpUlong;
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 
         return RetVal;
 }
@@ -2684,7 +2967,7 @@ rtl8125_csi_fun0_write_byte(struct rtl81
                 rtl8125_csi_other_fun_write( tp, 0, RegAlignAddr, TmpUlong );
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 }
 
 u32 rtl8125_eri_read_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, int type, const u32 base_address)
@@ -2716,8 +2999,8 @@ u32 rtl8125_eri_read_with_oob_base_addre
 
                 RTL_W32(tp, ERIAR, eri_cmd);
 
-                for (i = 0; i < 10; i++) {
-                        udelay(100);
+                for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8125_CHANNEL_WAIT_TIME);
 
                         /* Check if the RTL8125 has completed ERI read */
                         if (RTL_R32(tp, ERIAR) & ERIAR_Flag)
@@ -2741,7 +3024,7 @@ u32 rtl8125_eri_read_with_oob_base_addre
                 }
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 
         return value2;
 }
@@ -2790,8 +3073,8 @@ int rtl8125_eri_write_with_oob_base_addr
 
                 RTL_W32(tp, ERIAR, eri_cmd);
 
-                for (i = 0; i < 10; i++) {
-                        udelay(100);
+                for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+                        udelay(R8125_CHANNEL_WAIT_TIME);
 
                         /* Check if the RTL8125 has completed ERI write */
                         if (!(RTL_R32(tp, ERIAR) & ERIAR_Flag))
@@ -2807,7 +3090,7 @@ int rtl8125_eri_write_with_oob_base_addr
                 }
         }
 
-        udelay(20);
+        udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
 
         return 0;
 }
@@ -2829,6 +3112,7 @@ rtl8125_enable_rxdvgate(struct net_devic
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_3);
                 mdelay(2);
                 break;
@@ -2847,6 +3131,7 @@ rtl8125_disable_rxdvgate(struct net_devi
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_3);
                 mdelay(2);
                 break;
@@ -2940,6 +3225,7 @@ rtl8125_wait_txrx_fifo_empty(struct net_
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_stop_all_request(dev);
                 break;
         }
@@ -2951,6 +3237,7 @@ rtl8125_wait_txrx_fifo_empty(struct net_
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 for (i = 0; i < 3000; i++) {
                         udelay(50);
                         if ((RTL_R8(tp, MCUCmd_reg) & (Txfifo_empty | Rxfifo_empty)) == (Txfifo_empty | Rxfifo_empty))
@@ -2963,6 +3250,7 @@ rtl8125_wait_txrx_fifo_empty(struct net_
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 for (i = 0; i < 3000; i++) {
                         udelay(50);
                         if ((RTL_R16(tp, IntrMitigate) & (BIT_0 | BIT_1 | BIT_8)) == (BIT_0 | BIT_1 | BIT_8))
@@ -3122,12 +3410,21 @@ rtl8125_irq_mask_and_ack(struct rtl8125_
 }
 
 static void
+rtl8125_disable_rx_packet_filter(struct rtl8125_private *tp)
+{
+
+        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) &
+                ~(AcceptErr | AcceptRunt |AcceptBroadcast | AcceptMulticast |
+                  AcceptMyPhys |  AcceptAllPhys));
+}
+
+static void
 rtl8125_nic_reset(struct net_device *dev)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
         int i;
 
-        RTL_W32(tp, RxConfig, (RX_DMA_BURST << RxCfgDMAShift));
+        rtl8125_disable_rx_packet_filter(tp);
 
         rtl8125_enable_rxdvgate(dev);
 
@@ -3176,6 +3473,7 @@ rtl8125_hw_clear_timer_int(struct net_de
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W32(tp, TIMER_INT0_8125, 0x0000);
                 RTL_W32(tp, TIMER_INT1_8125, 0x0000);
                 RTL_W32(tp, TIMER_INT2_8125, 0x0000);
@@ -3359,6 +3657,7 @@ rtl8125_issue_offset_99_event(struct rtl
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xE09A,  rtl8125_mac_ocp_read(tp, 0xE09A) | BIT_0);
                 break;
         }
@@ -3392,6 +3691,7 @@ static int rtl8125_enable_eee_plus(struc
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xE080, rtl8125_mac_ocp_read(tp, 0xE080)|BIT_1);
                 break;
 
@@ -3416,9 +3716,9 @@ static int rtl8125_disable_eee_plus(stru
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xE080, rtl8125_mac_ocp_read(tp, 0xE080)&~BIT_1);
                 break;
-
         default:
 //      dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support EEEPlus\n");
                 ret = -EOPNOTSUPP;
@@ -3428,6 +3728,40 @@ static int rtl8125_disable_eee_plus(stru
         return ret;
 }
 
+static void rtl8125_enable_double_vlan(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+                RTL_W16(tp, DOUBLE_VLAN_CONFIG, 0xf002);
+                break;
+        default:
+                break;
+        }
+}
+
+static void rtl8125_disable_double_vlan(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+                RTL_W16(tp, DOUBLE_VLAN_CONFIG, 0);
+                break;
+        default:
+                break;
+        }
+}
+
 static void
 rtl8125_link_on_patch(struct net_device *dev)
 {
@@ -3443,14 +3777,20 @@ rtl8125_link_on_patch(struct net_device
                         RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_25) & ~(BIT_19 | BIT_24));
         }
 
-        if ((tp->mcfg == CFG_METHOD_2 ||
-             tp->mcfg == CFG_METHOD_3 ||
-             tp->mcfg == CFG_METHOD_4 ||
-             tp->mcfg == CFG_METHOD_5 ||
-             tp->mcfg == CFG_METHOD_6 ||
-             tp->mcfg == CFG_METHOD_7) &&
-            (RTL_R8(tp, PHYstatus) & _10bps))
-                rtl8125_enable_eee_plus(tp);
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
+                if (RTL_R8(tp, PHYstatus) & _10bps)
+                        rtl8125_enable_eee_plus(tp);
+                break;
+        default:
+                break;
+        }
 
         rtl8125_hw_start(dev);
 
@@ -3474,18 +3814,24 @@ rtl8125_link_down_patch(struct net_devic
         tp->phy_reg_gbsr = 0;
         tp->phy_reg_status_2500 = 0;
 
-        if (tp->mcfg == CFG_METHOD_2 ||
-            tp->mcfg == CFG_METHOD_3 ||
-            tp->mcfg == CFG_METHOD_4 ||
-            tp->mcfg == CFG_METHOD_5 ||
-            tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7)
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_disable_eee_plus(tp);
-
-        netif_tx_stop_all_queues(dev);
+                break;
+        default:
+                break;
+        }
 
         netif_carrier_off(dev);
 
+        netif_tx_disable(dev);
+
         rtl8125_hw_reset(dev);
 
         rtl8125_tx_clear(tp);
@@ -3605,12 +3951,13 @@ rtl8125_enable_ocp_phy_power_saving(stru
         struct rtl8125_private *tp = netdev_priv(dev);
         u16 val;
 
-         if (tp->mcfg == CFG_METHOD_2 ||
-             tp->mcfg == CFG_METHOD_3 ||
-             tp->mcfg == CFG_METHOD_4 ||
-			 tp->mcfg == CFG_METHOD_5 ||
-			 tp->mcfg == CFG_METHOD_6 ||
-			 tp->mcfg == CFG_METHOD_7) {
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8) {
                 val = mdio_direct_read_phy_ocp(tp, 0xC416);
                 if (val != 0x0050) {
                         rtl8125_set_phy_mcu_patch_request(tp);
@@ -3633,7 +3980,8 @@ rtl8125_disable_ocp_phy_power_saving(str
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7) {
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8) {
                 val = mdio_direct_read_phy_ocp(tp, 0xC416);
                 if (val != 0x0500) {
                         rtl8125_set_phy_mcu_patch_request(tp);
@@ -3667,6 +4015,7 @@ rtl8125_disable_pci_offset_99(struct rtl
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xE032,  rtl8125_mac_ocp_read(tp, 0xE032) & ~(BIT_0 | BIT_1));
                 break;
         }
@@ -3678,6 +4027,7 @@ rtl8125_disable_pci_offset_99(struct rtl
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_csi_fun0_write_byte(tp, 0x99, 0x00);
                 break;
         }
@@ -3695,6 +4045,7 @@ rtl8125_enable_pci_offset_99(struct rtl8
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_csi_fun0_write_byte(tp, 0x99, tp->org_pci_offset_99);
                 break;
         }
@@ -3706,6 +4057,7 @@ rtl8125_enable_pci_offset_99(struct rtl8
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 csi_tmp = rtl8125_mac_ocp_read(tp, 0xE032);
                 csi_tmp &= ~(BIT_0 | BIT_1);
                 if (tp->org_pci_offset_99 & (BIT_5 | BIT_6))
@@ -3729,6 +4081,7 @@ rtl8125_init_pci_offset_99(struct rtl812
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xCDD0, 0x9003);
                 csi_tmp = rtl8125_mac_ocp_read(tp, 0xE034);
                 csi_tmp |= (BIT_15 | BIT_14);
@@ -3769,6 +4122,7 @@ rtl8125_disable_pci_offset_180(struct rt
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 csi_tmp = rtl8125_mac_ocp_read(tp, 0xE092);
                 csi_tmp &= 0xFF00;
                 rtl8125_mac_ocp_write(tp, 0xE092, csi_tmp);
@@ -3788,6 +4142,7 @@ rtl8125_enable_pci_offset_180(struct rtl
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 csi_tmp = rtl8125_mac_ocp_read(tp, 0xE094);
                 csi_tmp &= 0x00FF;
                 rtl8125_mac_ocp_write(tp, 0xE094, csi_tmp);
@@ -3801,6 +4156,7 @@ rtl8125_enable_pci_offset_180(struct rtl
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 csi_tmp = rtl8125_mac_ocp_read(tp, 0xE092);
                 csi_tmp &= 0xFF00;
                 csi_tmp |= BIT_2;
@@ -3812,10 +4168,7 @@ rtl8125_enable_pci_offset_180(struct rtl
 static void
 rtl8125_init_pci_offset_180(struct rtl8125_private *tp)
 {
-        if (tp->org_pci_offset_180 & (BIT_0|BIT_1))
-                rtl8125_enable_pci_offset_180(tp);
-        else
-                rtl8125_disable_pci_offset_180(tp);
+        rtl8125_enable_pci_offset_180(tp);
 }
 
 static void
@@ -3830,6 +4183,7 @@ rtl8125_set_pci_99_180_exit_driver_para(
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 if (tp->org_pci_offset_99 & BIT_2)
                         rtl8125_issue_offset_99_event(tp);
                 rtl8125_disable_pci_offset_99(tp);
@@ -3843,6 +4197,7 @@ rtl8125_set_pci_99_180_exit_driver_para(
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_disable_pci_offset_180(tp);
                 break;
         }
@@ -3908,6 +4263,7 @@ rtl8125_hw_d3_para(struct net_device *de
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
                 rtl8125_enable_cfg9346_write(tp);
                 RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
@@ -3929,6 +4285,7 @@ rtl8125_hw_d3_para(struct net_device *de
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xEA18, 0x0064);
                 break;
         }
@@ -3941,7 +4298,8 @@ rtl8125_hw_d3_para(struct net_device *de
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7)
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8)
                 rtl8125_disable_ocp_phy_power_saving(dev);
 
         rtl8125_disable_rxdvgate(dev);
@@ -4206,41 +4564,37 @@ rtl8125_set_wol_link_speed(struct net_de
         ctrl_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D4);
         ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL);
 
-        aner = anlpar = gbsr = status_2500 = 0;
+        aner = tp->phy_reg_aner;
+        anlpar = tp->phy_reg_anlpar;
+        gbsr = tp->phy_reg_gbsr;
+        status_2500 = tp->phy_reg_status_2500;
         if (tp->link_ok(dev)) {
                 aner = rtl8125_mdio_read(tp, MII_EXPANSION);
                 anlpar = rtl8125_mdio_read(tp, MII_LPA);
                 gbsr = rtl8125_mdio_read(tp, MII_STAT1000);
                 status_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D6);
-        } else {
-                if (netif_running(dev)) {
-                        aner = tp->phy_reg_aner;
-                        anlpar = tp->phy_reg_anlpar;
-                        gbsr = tp->phy_reg_gbsr;
-                        status_2500 = tp->phy_reg_status_2500;
-                }
         }
 
+        adv = tp->advertising;
         if ((aner | anlpar | gbsr | status_2500) == 0) {
                 int auto_nego_tmp = 0;
-                adv = tp->advertising;
-                if ((adv & ADVERTISED_10baseT_Half) && (anlpar & LPA_10HALF))
+                if (adv & ADVERTISED_10baseT_Half)
                         auto_nego_tmp |= ADVERTISE_10HALF;
-                if ((adv & ADVERTISED_10baseT_Full) && (anlpar & LPA_10FULL))
+                if (adv & ADVERTISED_10baseT_Full)
                         auto_nego_tmp |= ADVERTISE_10FULL;
-                if ((adv & ADVERTISED_100baseT_Half) && (anlpar & LPA_100HALF))
+                if (adv & ADVERTISED_100baseT_Half)
                         auto_nego_tmp |= ADVERTISE_100HALF;
-                if ((adv & ADVERTISED_100baseT_Full) && (anlpar & LPA_100FULL))
+                if (adv & ADVERTISED_100baseT_Full)
                         auto_nego_tmp |= ADVERTISE_100FULL;
 
-                if (auto_nego_tmp == 0)	goto exit;
+                if (auto_nego_tmp == 0)
+                        goto exit;
 
                 auto_nego |= auto_nego_tmp;
                 goto skip_check_lpa;
         }
         if (!(aner & EXPANSION_NWAY)) goto exit;
 
-        adv = tp->advertising;
         if ((adv & ADVERTISED_10baseT_Half) && (anlpar & LPA_10HALF))
                 auto_nego |= ADVERTISE_10HALF;
         else if ((adv & ADVERTISED_10baseT_Full) && (anlpar & LPA_10FULL))
@@ -4301,7 +4655,8 @@ rtl8125_powerdown_pll(struct net_device
                     tp->mcfg == CFG_METHOD_4 ||
                     tp->mcfg == CFG_METHOD_5 ||
                     tp->mcfg == CFG_METHOD_6 ||
-                    tp->mcfg == CFG_METHOD_7) {
+                    tp->mcfg == CFG_METHOD_7 ||
+                    tp->mcfg == CFG_METHOD_8) {
                         rtl8125_enable_cfg9346_write(tp);
                         RTL_W8(tp, Config2, RTL_R8(tp, Config2) | PMSTS_En);
                         rtl8125_disable_cfg9346_write(tp);
@@ -4340,6 +4695,7 @@ rtl8125_powerdown_pll(struct net_device
                 case CFG_METHOD_5:
                 case CFG_METHOD_6:
                 case CFG_METHOD_7:
+                case CFG_METHOD_8:
                         RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) & ~BIT_7);
                         break;
                 }
@@ -4352,6 +4708,7 @@ rtl8125_powerdown_pll(struct net_device
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_6);
                 break;
         }
@@ -4368,6 +4725,7 @@ static void rtl8125_powerup_pll(struct n
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) | BIT_7 | BIT_6);
                 break;
         }
@@ -4463,7 +4821,7 @@ rtl8125_set_speed_xmii(struct net_device
                        u8 autoneg,
                        u32 speed,
                        u8 duplex,
-                       u32 adv)
+                       u64 adv)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
         int auto_nego = 0;
@@ -4475,7 +4833,8 @@ rtl8125_set_speed_xmii(struct net_device
         ClearEthPhyOcpBit(tp, 0xA428, BIT_9);
         ClearEthPhyOcpBit(tp, 0xA5EA, BIT_0);
 
-        if (speed != SPEED_2500 &&
+        if (speed != SPEED_5000 &&
+            speed != SPEED_2500 &&
             (speed != SPEED_1000) &&
             (speed != SPEED_100) &&
             (speed != SPEED_10)) {
@@ -4486,7 +4845,7 @@ rtl8125_set_speed_xmii(struct net_device
         giga_ctrl = rtl8125_mdio_read(tp, MII_CTRL1000);
         giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
         ctrl_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D4);
-        ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL);
+        ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL | RTK_ADVERTISE_5000FULL);
 
         if (autoneg == AUTONEG_ENABLE) {
                 /*n-way force*/
@@ -4509,6 +4868,10 @@ rtl8125_set_speed_xmii(struct net_device
                         giga_ctrl |= ADVERTISE_1000FULL;
                 if (adv & ADVERTISED_2500baseX_Full)
                         ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+                if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                        if (adv & RTK_ADVERTISED_5000baseX_Full)
+                                ctrl_2500 |= RTK_ADVERTISE_5000FULL;
+                }
 
                 //flow control
                 if (dev->mtu <= ETH_DATA_LEN && tp->fcpause == rtl8125_fc_full)
@@ -4550,7 +4913,7 @@ rtl8125_set_speed(struct net_device *dev
                   u8 autoneg,
                   u32 speed,
                   u8 duplex,
-                  u32 adv)
+                  u64 adv)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
         int ret;
@@ -4576,7 +4939,7 @@ rtl8125_set_settings(struct net_device *
         u8 autoneg;
         u32 speed;
         u8 duplex;
-        u32 supported, advertising;
+        u64 supported = 0, advertising = 0;
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
         autoneg = cmd->autoneg;
@@ -4585,13 +4948,14 @@ rtl8125_set_settings(struct net_device *
         supported = cmd->supported;
         advertising = cmd->advertising;
 #else
+        struct rtl8125_private *tp = netdev_priv(dev);
         const struct ethtool_link_settings *base = &cmd->base;
         autoneg = base->autoneg;
         speed = base->speed;
         duplex = base->duplex;
-        ethtool_convert_link_mode_to_legacy_u32(&supported,
+        ethtool_convert_link_mode_to_legacy_u32((u32*)&supported,
                                                 cmd->link_modes.supported);
-        ethtool_convert_link_mode_to_legacy_u32(&advertising,
+        ethtool_convert_link_mode_to_legacy_u32((u32*)&advertising,
                                                 cmd->link_modes.advertising);
         if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
                      cmd->link_modes.supported))
@@ -4599,6 +4963,14 @@ rtl8125_set_settings(struct net_device *
         if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
                      cmd->link_modes.advertising))
                 advertising |= ADVERTISED_2500baseX_Full;
+        if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                if (test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                             cmd->link_modes.supported))
+                        supported |= RTK_ADVERTISED_5000baseX_Full;
+                if (test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                             cmd->link_modes.advertising))
+                        advertising |= RTK_ADVERTISED_5000baseX_Full;
+        }
 #endif
         if (advertising & ~supported)
                 return -EINVAL;
@@ -4744,7 +5116,8 @@ rtl8125_vlan_rx_register(struct net_devi
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7) {
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8) {
                 if (tp->vlgrp) {
                         tp->rtl8125_rx_config |= (EnableInnerVlan | EnableOuterVlan);
                         RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | (EnableInnerVlan | EnableOuterVlan))
@@ -4902,7 +5275,7 @@ static void rtl8125_gset_xmii(struct net
         u8 autoneg, duplex;
         u32 speed = 0;
         u16 bmcr;
-        u32 supported, advertising;
+        u64 supported, advertising;
         u8 report_lpa = 0;
 
         supported = SUPPORTED_10baseT_Half |
@@ -4916,7 +5289,7 @@ static void rtl8125_gset_xmii(struct net
                     SUPPORTED_Pause	|
                     SUPPORTED_Asym_Pause;
 
-        if (tp->mcfg == CFG_METHOD_6 || tp->mcfg == CFG_METHOD_7)
+        if (!HW_SUPP_PHY_LINK_SPEED_2500M(tp))
                 supported &= ~SUPPORTED_2500baseX_Full;
 
         advertising = ADVERTISED_TP;
@@ -4938,8 +5311,6 @@ static void rtl8125_gset_xmii(struct net
                         advertising |= ADVERTISED_100baseT_Full;
                 if (tp->phy_1000_ctrl_reg & ADVERTISE_1000FULL)
                         advertising |= ADVERTISED_1000baseT_Full;
-                if (tp->phy_2500_ctrl_reg & RTK_ADVERTISE_2500FULL)
-                        advertising |= ADVERTISED_2500baseX_Full;
         } else {
                 autoneg = AUTONEG_DISABLE;
         }
@@ -4950,14 +5321,7 @@ static void rtl8125_gset_xmii(struct net
 
         if (report_lpa) {
                 /*link on*/
-                if (status & _2500bpsF)
-                        speed = SPEED_2500;
-                else if (status & _1000bpsF)
-                        speed = SPEED_1000;
-                else if (status & _100bps)
-                        speed = SPEED_100;
-                else if (status & _10bps)
-                        speed = SPEED_10;
+                speed = rtl8125_convert_link_speed(status);
 
                 if (status & TxFlowCtrl)
                         advertising |= ADVERTISED_Asym_Pause;
@@ -4965,7 +5329,8 @@ static void rtl8125_gset_xmii(struct net
                 if (status & RxFlowCtrl)
                         advertising |= ADVERTISED_Pause;
 
-                duplex = ((status & (_1000bpsF | _2500bpsF)) || (status & FullDup)) ?
+                duplex = ((status & (_1000bpsF | _2500bpsF | _5000bpsF)) ||
+                          (status & FullDup)) ?
                          DUPLEX_FULL : DUPLEX_HALF;
 
                 /*link partner*/
@@ -4997,8 +5362,8 @@ static void rtl8125_gset_xmii(struct net
         }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
-        cmd->supported = supported;
-        cmd->advertising = advertising;
+        cmd->supported = (u32)supported;
+        cmd->advertising = (u32)advertising;
         cmd->autoneg = autoneg;
         cmd->speed = speed;
         cmd->duplex = duplex;
@@ -5024,6 +5389,12 @@ static void rtl8125_gset_xmii(struct net
                 linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
                                  cmd->link_modes.advertising, 1);
         }
+        if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                                 cmd->link_modes.supported, 1);
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                                 cmd->link_modes.advertising, tp->phy_2500_ctrl_reg & RTK_ADVERTISE_5000FULL);
+        }
         if (report_lpa) {
                 if (lpa_adv & ADVERTISED_2500baseX_Full) {
                         linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
@@ -5100,6 +5471,7 @@ static void rtl8125_get_regs(struct net_
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
         default:
                 for (i = 0; i < R8125_ERI_REGS_SIZE; i+=4) {
                         *(u32*)data = rtl8125_eri_read(tp, i , 4, ERIAR_ExGMAC);
@@ -5254,7 +5626,7 @@ static void rtl8125_get_ringparam(struct
         struct rtl8125_private *tp = netdev_priv(dev);
 
         ring->rx_max_pending = MAX_NUM_TX_DESC;
-        ring->tx_max_pending = MAX_NUM_RX_DESC;;
+        ring->tx_max_pending = MAX_NUM_RX_DESC;
         ring->rx_pending = tp->rx_ring[0].num_rx_desc;
         ring->tx_pending = tp->tx_ring[0].num_tx_desc;
 }
@@ -5407,6 +5779,7 @@ static int rtl_get_eeprom(struct net_dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
         default:
                 VPD_addr = 0xD2;
                 VPD_data = 0xD4;
@@ -5518,6 +5891,7 @@ static int rtl8125_enable_eee(struct rtl
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W16(tp, EEE_TXIDLE_TIMER_8125, eee->tx_lpi_timer);
 
                 SetMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
@@ -5530,6 +5904,8 @@ static int rtl8125_enable_eee(struct rtl
                         SetEthPhyOcpBit(tp, 0xA6D4, BIT_0);
                 else
                         ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+                if (HW_SUPP_PHY_LINK_SPEED_5000M(tp))
+                        ClearEthPhyOcpBit(tp, 0xA6D4, BIT_1);
 
                 ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
                 ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
@@ -5549,6 +5925,7 @@ static int rtl8125_enable_eee(struct rtl
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_set_phy_mcu_patch_request(tp);
                 ClearMcuAccessRegBit(tp, 0xE052, BIT_0);
                 ClearEthPhyOcpBit(tp, 0xA442, BIT_12 | BIT_13);
@@ -5583,10 +5960,13 @@ static int rtl8125_disable_eee(struct rt
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 ClearMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
 
                 ClearEthPhyOcpBit(tp, 0xA5D0, (BIT_2 | BIT_1));
                 ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+                if (HW_SUPP_PHY_LINK_SPEED_5000M(tp))
+                        ClearEthPhyOcpBit(tp, 0xA6D4, BIT_1);
 
                 ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
                 ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
@@ -5606,6 +5986,7 @@ static int rtl8125_disable_eee(struct rt
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_set_phy_mcu_patch_request(tp);
                 ClearMcuAccessRegBit(tp, 0xE052, BIT_0);
                 ClearEthPhyOcpBit(tp, 0xA442, BIT_12 | BIT_13);
@@ -5647,17 +6028,30 @@ rtl8125_tx_lpi_timer_to_us(struct rtl812
         u32 to_us;
         u16 status;
 
-        //2.5G : tx_lpi_timer * 3.2ns
-        //Giga: tx_lpi_timer * 8ns
-        //100M : tx_lpi_timer * 80ns
         to_us = tx_lpi_timer * 80;
         status = RTL_R16(tp, PHYstatus);
         if (status & LinkStatus) {
                 /*link on*/
-                if (status & _2500bpsF)
-                        to_us = (tx_lpi_timer * 32) / 10;
-                else if (status & _1000bpsF)
-                        to_us = tx_lpi_timer * 8;
+                if (HW_SUPP_PHY_LINK_SPEED_5000M(tp)) {
+                        //5G : tx_lpi_timer * 12.8ns
+                        //2.5G : tx_lpi_timer * 25.6ns
+                        //Giga: tx_lpi_timer * 8ns
+                        //100M : tx_lpi_timer * 80ns
+                        if (status & (_5000bpsF))
+                                to_us = (tx_lpi_timer * 128) / 10;
+                        else if (status & _2500bpsF)
+                                to_us = (tx_lpi_timer * 256) / 10;
+                        else if (status & _1000bpsF)
+                                to_us = tx_lpi_timer * 8;
+                } else {
+                        //2.5G : tx_lpi_timer * 3.2ns
+                        //Giga: tx_lpi_timer * 8ns
+                        //100M : tx_lpi_timer * 80ns
+                        if (status & _2500bpsF)
+                                to_us = (tx_lpi_timer * 32) / 10;
+                        else if (status & _1000bpsF)
+                                to_us = tx_lpi_timer * 8;
+                }
         }
 
         //ns to us
@@ -5878,6 +6272,7 @@ static int rtl8125_enable_green_feature(
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 mdio_direct_write_phy_ocp(tp, 0xA436, 0x8011);
                 SetEthPhyOcpBit(tp, 0xA438, BIT_15);
                 rtl8125_mdio_write(tp, 0x00, 0x9200);
@@ -5901,6 +6296,7 @@ static int rtl8125_disable_green_feature
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 mdio_direct_write_phy_ocp(tp, 0xA436, 0x8011);
                 ClearEthPhyOcpBit(tp, 0xA438, BIT_15);
                 rtl8125_mdio_write(tp, 0x00, 0x9200);
@@ -5950,6 +6346,11 @@ static void rtl8125_get_mac_version(stru
 
                 tp->efuse_ver = EFUSE_SUPPORT_V4;
                 break;
+        case 0x64800000:
+                tp->mcfg = CFG_METHOD_8;
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
         default:
                 printk("unknown chip version (%x)\n",reg);
                 tp->mcfg = CFG_METHOD_DEFAULT;
@@ -6010,6 +6411,7 @@ rtl8125_clear_phy_ups_reg(struct net_dev
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 ClearEthPhyOcpBit(tp, 0xA466, BIT_0);
                 break;
         };
@@ -6026,7 +6428,8 @@ rtl8125_is_ups_resume(struct net_device
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7)
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8)
                 return (rtl8125_mac_ocp_read(tp, 0xD42C) & BIT_8);
 
         return 0;
@@ -6058,7 +6461,8 @@ rtl8125_wait_phy_ups_resume(struct net_d
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7) {
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8) {
                 do {
                         TmpPhyState = mdio_direct_read_phy_ocp(tp, 0xA420);
                         TmpPhyState &= 0x7;
@@ -6094,19 +6498,11 @@ rtl8125_exit_oob(struct net_device *dev)
         struct rtl8125_private *tp = netdev_priv(dev);
         u16 data16;
 
-        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) & ~(AcceptErr | AcceptRunt | AcceptBroadcast | AcceptMulticast | AcceptMyPhys |  AcceptAllPhys));
-
-        switch (tp->mcfg) {
-        case CFG_METHOD_2:
-        case CFG_METHOD_3:
-        case CFG_METHOD_6:
-                rtl8125_dash2_disable_txrx(dev);
-                break;
-        }
+        rtl8125_disable_rx_packet_filter(tp);
 
-        if (tp->DASH) {
-                rtl8125_driver_stop(tp);
+        if (HW_DASH_SUPPORT_DASH(tp)) {
                 rtl8125_driver_start(tp);
+                rtl8125_dash2_disable_txrx(dev);
 #ifdef ENABLE_DASH_SUPPORT
                 DashHwInit(dev);
 #endif
@@ -6123,6 +6519,7 @@ rtl8125_exit_oob(struct net_device *dev)
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xC0BC, 0x00FF);
                 break;
         }
@@ -6137,6 +6534,7 @@ rtl8125_exit_oob(struct net_device *dev)
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_disable_now_is_oob(tp);
 
                 data16 = rtl8125_mac_ocp_read(tp, 0xE8DE) & ~BIT_14;
@@ -6159,6 +6557,7 @@ rtl8125_exit_oob(struct net_device *dev)
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 if (rtl8125_is_ups_resume(dev)) {
                         rtl8125_wait_phy_ups_resume(dev, 2);
                         rtl8125_clear_ups_resume_bit(dev);
@@ -6182,6 +6581,7 @@ rtl8125_hw_disable_mac_mcu_bps(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_enable_cfg9346_write(tp);
                 RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
                 RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
@@ -6196,6 +6596,7 @@ rtl8125_hw_disable_mac_mcu_bps(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xFC48, 0x0000);
                 break;
         }
@@ -6207,6 +6608,7 @@ rtl8125_hw_disable_mac_mcu_bps(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 for (regAddr = 0xFC28; regAddr < 0xFC48; regAddr += 2) {
                         rtl8125_mac_ocp_write(tp, regAddr, 0x0000);
                 }
@@ -6433,6 +6835,32 @@ rtl8125_set_mac_mcu_8125b_2(struct net_d
 }
 
 static void
+rtl8125_set_mac_mcu_8126a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code_8126a_1[] =  {
+                0xE010, 0xE019, 0xE01B, 0xE01D, 0xE01F, 0xE021, 0xE023, 0xE025, 0xE027,
+                0xE029, 0xE02B, 0xE02D, 0xE02F, 0xE031, 0xE033, 0xE035, 0x48C0, 0x9C66,
+                0x7446, 0x4840, 0x48C1, 0x48C2, 0x9C46, 0xC402, 0xBC00, 0x0AD6, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+                0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000
+        };
+
+        rtl8125_hw_disable_mac_mcu_bps(dev);
+
+        rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code_8126a_1, ARRAY_SIZE(mcu_patch_code_8126a_1));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x0AAA);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x0001);
+}
+
+static void
 rtl8125_hw_mac_mcu_config(struct net_device *dev)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
@@ -6454,6 +6882,9 @@ rtl8125_hw_mac_mcu_config(struct net_dev
         case CFG_METHOD_7:
                 rtl8125_set_mac_mcu_8125b_2(dev);
                 break;
+        case CFG_METHOD_8:
+                rtl8125_set_mac_mcu_8126a_1(dev);
+                break;
         }
 }
 #endif
@@ -6502,6 +6933,7 @@ rtl8125_hw_init(struct net_device *dev)
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_enable_cfg9346_write(tp);
                 RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
                 RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
@@ -6518,6 +6950,7 @@ rtl8125_hw_init(struct net_device *dev)
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xD40A, rtl8125_mac_ocp_read( tp, 0xD40A) & ~(BIT_4));
                 break;
         }
@@ -6533,7 +6966,8 @@ rtl8125_hw_init(struct net_device *dev)
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7)
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8)
                 rtl8125_disable_ocp_phy_power_saving(dev);
 
         //Set PCIE uncorrectable error status mask pcie 0x108
@@ -6673,6 +7107,8 @@ rtl8125_hw_ephy_config(struct net_device
                 rtl8125_ephy_write(tp, 0x42, 0x60C2);
                 rtl8125_ephy_write(tp, 0x69, 0xFF00);
                 break;
+        case CFG_METHOD_8:
+                break;
         }
 }
 
@@ -6688,6 +7124,7 @@ rtl8125_get_hw_phy_mcu_code_ver(struct r
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
                 hw_ram_code_ver = mdio_direct_read_phy_ocp(tp, 0xA438);
                 break;
@@ -6773,6 +7210,7 @@ rtl8125_write_hw_phy_mcu_code_ver(struct
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
                 mdio_direct_write_phy_ocp(tp, 0xA438, tp->sw_ram_code_ver);
                 tp->hw_ram_code_ver = tp->sw_ram_code_ver;
@@ -9222,6 +9660,550 @@ static const u16 phy_mcu_ram_code_8125b_
         0xFFFF, 0xFFFF
 };
 
+static const u16 phy_mcu_ram_code_8126a_1_1[] = {
+        0xa436, 0x8023, 0xa438, 0x4900, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xBFBA, 0xE000, 0xBF1A, 0xC1B9, 0xBFA8, 0x10F0, 0xBFB0, 0x0210,
+        0xBFB4, 0xE7E4, 0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000,
+        0xa436, 0xA012, 0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800,
+        0xa438, 0x8010, 0xa438, 0x1800, 0xa438, 0x8062, 0xa438, 0x1800,
+        0xa438, 0x8069, 0xa438, 0x1800, 0xa438, 0x80e2, 0xa438, 0x1800,
+        0xa438, 0x80eb, 0xa438, 0x1800, 0xa438, 0x80f5, 0xa438, 0x1800,
+        0xa438, 0x811b, 0xa438, 0x1800, 0xa438, 0x8120, 0xa438, 0xd500,
+        0xa438, 0xd049, 0xa438, 0xd1b9, 0xa438, 0xa208, 0xa438, 0x8208,
+        0xa438, 0xd503, 0xa438, 0xa104, 0xa438, 0x0c07, 0xa438, 0x0902,
+        0xa438, 0xd500, 0xa438, 0xbc10, 0xa438, 0xc484, 0xa438, 0xd503,
+        0xa438, 0xcc02, 0xa438, 0xcd0d, 0xa438, 0xaf01, 0xa438, 0xd500,
+        0xa438, 0xd703, 0xa438, 0x4531, 0xa438, 0xbd08, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd75e, 0xa438, 0x5fb3, 0xa438, 0xd503,
+        0xa438, 0xd04d, 0xa438, 0xd1c7, 0xa438, 0x0cf0, 0xa438, 0x0e10,
+        0xa438, 0xd704, 0xa438, 0x5ffc, 0xa438, 0xd04d, 0xa438, 0xd1c7,
+        0xa438, 0x0cf0, 0xa438, 0x0e20, 0xa438, 0xd704, 0xa438, 0x5ffc,
+        0xa438, 0xd04d, 0xa438, 0xd1c7, 0xa438, 0x0cf0, 0xa438, 0x0e40,
+        0xa438, 0xd704, 0xa438, 0x5ffc, 0xa438, 0xd04d, 0xa438, 0xd1c7,
+        0xa438, 0x0cf0, 0xa438, 0x0e80, 0xa438, 0xd704, 0xa438, 0x5ffc,
+        0xa438, 0xd07b, 0xa438, 0xd1c5, 0xa438, 0x8ef0, 0xa438, 0xd704,
+        0xa438, 0x5ffc, 0xa438, 0x9d08, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd75e, 0xa438, 0x7fb3, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000, 0xa438, 0x181f,
+        0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x8059, 0xa438, 0x60ad,
+        0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd703, 0xa438, 0x5fbb,
+        0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd719, 0xa438, 0x7fa8,
+        0xa438, 0xd500, 0xa438, 0xd049, 0xa438, 0xd1b9, 0xa438, 0x1800,
+        0xa438, 0x0f0b, 0xa438, 0xd500, 0xa438, 0xd07b, 0xa438, 0xd1b5,
+        0xa438, 0xd0f6, 0xa438, 0xd1c5, 0xa438, 0x1800, 0xa438, 0x1049,
+        0xa438, 0xd707, 0xa438, 0x4121, 0xa438, 0xd706, 0xa438, 0x40fa,
+        0xa438, 0xd099, 0xa438, 0xd1c6, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd704, 0xa438, 0x5fbc, 0xa438, 0xbc80, 0xa438, 0xc489,
+        0xa438, 0xd503, 0xa438, 0xcc08, 0xa438, 0xcd46, 0xa438, 0xaf01,
+        0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x0903, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd75e, 0xa438, 0x5f6d, 0xa438, 0x1000,
+        0xa438, 0x181f, 0xa438, 0xd504, 0xa438, 0xa210, 0xa438, 0xd500,
+        0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd719, 0xa438, 0x5fbc,
+        0xa438, 0xd504, 0xa438, 0x8210, 0xa438, 0xd503, 0xa438, 0xc6d0,
+        0xa438, 0xa521, 0xa438, 0xcd49, 0xa438, 0xaf01, 0xa438, 0xd504,
+        0xa438, 0xa220, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x16bb,
+        0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000, 0xa438, 0x181f,
+        0xa438, 0xd503, 0xa438, 0xa704, 0xa438, 0x0c07, 0xa438, 0x0904,
+        0xa438, 0xd504, 0xa438, 0xa102, 0xa438, 0xd500, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd718, 0xa438, 0x5fab, 0xa438, 0xd503,
+        0xa438, 0xc6f0, 0xa438, 0xa521, 0xa438, 0xd505, 0xa438, 0xa404,
+        0xa438, 0xd500, 0xa438, 0xd701, 0xa438, 0x6085, 0xa438, 0xd504,
+        0xa438, 0xc9f1, 0xa438, 0xf003, 0xa438, 0xd504, 0xa438, 0xc9f0,
+        0xa438, 0xd503, 0xa438, 0xcd4a, 0xa438, 0xaf01, 0xa438, 0xd500,
+        0xa438, 0xd504, 0xa438, 0xa802, 0xa438, 0xd500, 0xa438, 0x1000,
+        0xa438, 0x16bb, 0xa438, 0xd707, 0xa438, 0x5fb1, 0xa438, 0xd707,
+        0xa438, 0x5f10, 0xa438, 0xd505, 0xa438, 0xa402, 0xa438, 0xd503,
+        0xa438, 0xd707, 0xa438, 0x41a1, 0xa438, 0xd706, 0xa438, 0x60ba,
+        0xa438, 0x60fc, 0xa438, 0x0c07, 0xa438, 0x0204, 0xa438, 0xf009,
+        0xa438, 0x0c07, 0xa438, 0x0202, 0xa438, 0xf006, 0xa438, 0x0c07,
+        0xa438, 0x0206, 0xa438, 0xf003, 0xa438, 0x0c07, 0xa438, 0x0202,
+        0xa438, 0xd500, 0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x80e0,
+        0xa438, 0x616d, 0xa438, 0xd701, 0xa438, 0x6065, 0xa438, 0x1800,
+        0xa438, 0x1229, 0xa438, 0x1000, 0xa438, 0x16bb, 0xa438, 0xd707,
+        0xa438, 0x6061, 0xa438, 0xd704, 0xa438, 0x5f7c, 0xa438, 0x1800,
+        0xa438, 0x124a, 0xa438, 0xd504, 0xa438, 0x8c0f, 0xa438, 0xd505,
+        0xa438, 0xa20e, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1871,
+        0xa438, 0x1800, 0xa438, 0x1899, 0xa438, 0xd70b, 0xa438, 0x60b0,
+        0xa438, 0xd05a, 0xa438, 0xd19a, 0xa438, 0x1800, 0xa438, 0x1aef,
+        0xa438, 0xd0ef, 0xa438, 0xd19a, 0xa438, 0x1800, 0xa438, 0x1aef,
+        0xa438, 0x1000, 0xa438, 0x1d09, 0xa438, 0xd708, 0xa438, 0x3399,
+        0xa438, 0x1b63, 0xa438, 0xd709, 0xa438, 0x5f5d, 0xa438, 0xd70b,
+        0xa438, 0x6130, 0xa438, 0xd70d, 0xa438, 0x6163, 0xa438, 0xd709,
+        0xa438, 0x430b, 0xa438, 0xd71e, 0xa438, 0x62c2, 0xa438, 0xb401,
+        0xa438, 0xf014, 0xa438, 0xc901, 0xa438, 0x1000, 0xa438, 0x810e,
+        0xa438, 0xf010, 0xa438, 0xc902, 0xa438, 0x1000, 0xa438, 0x810e,
+        0xa438, 0xf00c, 0xa438, 0xce04, 0xa438, 0xcf01, 0xa438, 0xd70a,
+        0xa438, 0x5fe2, 0xa438, 0xce04, 0xa438, 0xcf02, 0xa438, 0xc900,
+        0xa438, 0xd70a, 0xa438, 0x4057, 0xa438, 0xb401, 0xa438, 0x0800,
+        0xa438, 0x1800, 0xa438, 0x1b5d, 0xa438, 0xa480, 0xa438, 0xa2b0,
+        0xa438, 0xa806, 0xa438, 0x1800, 0xa438, 0x225c, 0xa438, 0xa7e8,
+        0xa438, 0xac08, 0xa438, 0x1800, 0xa438, 0x1a4e, 0xa436, 0xA026,
+        0xa438, 0x1a4d, 0xa436, 0xA024, 0xa438, 0x225a, 0xa436, 0xA022,
+        0xa438, 0x1b53, 0xa436, 0xA020, 0xa438, 0x1aed, 0xa436, 0xA006,
+        0xa438, 0x1892, 0xa436, 0xA004, 0xa438, 0x11a4, 0xa436, 0xA002,
+        0xa438, 0x103c, 0xa436, 0xA000, 0xa438, 0x0ea6, 0xa436, 0xA008,
+        0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0ff8, 0xa436, 0xA014, 0xa438, 0x0000, 0xa438, 0xD098,
+        0xa438, 0xc483, 0xa438, 0xc483, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152, 0xa438, 0x3fff,
+        0xa436, 0xA154, 0xa438, 0x0413, 0xa436, 0xA156, 0xa438, 0x1A32,
+        0xa436, 0xA158, 0xa438, 0x1CC0, 0xa436, 0xA15A, 0xa438, 0x3fff,
+        0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E, 0xa438, 0x3fff,
+        0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150, 0xa438, 0x000E,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8021, 0xa438, 0x1800, 0xa438, 0x8037, 0xa438, 0x1800,
+        0xa438, 0x803f, 0xa438, 0x1800, 0xa438, 0x8084, 0xa438, 0x1800,
+        0xa438, 0x80c5, 0xa438, 0x1800, 0xa438, 0x80cc, 0xa438, 0x1800,
+        0xa438, 0x80d5, 0xa438, 0xa00a, 0xa438, 0xa280, 0xa438, 0xa404,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x1800, 0xa438, 0x099b, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd700, 0xa438, 0x5fab, 0xa438, 0xa208, 0xa438, 0x8204,
+        0xa438, 0xcb38, 0xa438, 0xaa40, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x0b2a,
+        0xa438, 0x82a0, 0xa438, 0x8404, 0xa438, 0xa110, 0xa438, 0xd706,
+        0xa438, 0x4041, 0xa438, 0xa180, 0xa438, 0x1800, 0xa438, 0x0e7f,
+        0xa438, 0x8190, 0xa438, 0xcb93, 0xa438, 0x1000, 0xa438, 0x0ef4,
+        0xa438, 0xd704, 0xa438, 0x7fb8, 0xa438, 0xa008, 0xa438, 0xd706,
+        0xa438, 0x4040, 0xa438, 0xa002, 0xa438, 0xd705, 0xa438, 0x4079,
+        0xa438, 0x1000, 0xa438, 0x10ad, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x85f0, 0xa438, 0x9503, 0xa438, 0xd705, 0xa438, 0x40d9,
+        0xa438, 0xd70c, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d09,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d0a, 0xa438, 0x0cc0,
+        0xa438, 0x0d80, 0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x1000,
+        0xa438, 0x0ef4, 0xa438, 0x8020, 0xa438, 0xd705, 0xa438, 0x40d9,
+        0xa438, 0xd704, 0xa438, 0x609f, 0xa438, 0xd70c, 0xa438, 0x6043,
+        0xa438, 0x8504, 0xa438, 0xcb94, 0xa438, 0x1000, 0xa438, 0x0ef4,
+        0xa438, 0xd706, 0xa438, 0x7fa2, 0xa438, 0x800a, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x0cf0, 0xa438, 0x05a0, 0xa438, 0x9503,
+        0xa438, 0xd705, 0xa438, 0x40b9, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x8dc0, 0xa438, 0xf005, 0xa438, 0xa190, 0xa438, 0x0c1f,
+        0xa438, 0x0d17, 0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x104f,
+        0xa438, 0xd705, 0xa438, 0x39cc, 0xa438, 0x0c7d, 0xa438, 0x1800,
+        0xa438, 0x0e67, 0xa438, 0xcb96, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xab05, 0xa438, 0xac04, 0xa438, 0xac08, 0xa438, 0x9503,
+        0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x8dc0, 0xa438, 0x1000,
+        0xa438, 0x104f, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd706,
+        0xa438, 0x2215, 0xa438, 0x8099, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xae02, 0xa438, 0x9503, 0xa438, 0xd706, 0xa438, 0x6451,
+        0xa438, 0xd71f, 0xa438, 0x2e70, 0xa438, 0x0f00, 0xa438, 0xd706,
+        0xa438, 0x3290, 0xa438, 0x80be, 0xa438, 0xd704, 0xa438, 0x2e70,
+        0xa438, 0x8090, 0xa438, 0xd706, 0xa438, 0x339c, 0xa438, 0x8090,
+        0xa438, 0x8718, 0xa438, 0x8910, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xc500, 0xa438, 0x9503, 0xa438, 0x0c1f, 0xa438, 0x0d17,
+        0xa438, 0x8dc0, 0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8c04, 0xa438, 0x9503, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa280, 0xa438, 0xa404, 0xa438, 0x1800,
+        0xa438, 0x0f35, 0xa438, 0x1800, 0xa438, 0x0f07, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8c08, 0xa438, 0x8c04, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x0f02, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xaa10, 0xa438, 0x1800,
+        0xa438, 0x0c6b, 0xa438, 0x82a0, 0xa438, 0x8406, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xac04, 0xa438, 0x8602, 0xa438, 0x9503,
+        0xa438, 0x1800, 0xa438, 0x0e09, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x8308, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xc555, 0xa438, 0x9503, 0xa438, 0xa728,
+        0xa438, 0x8440, 0xa438, 0x0c03, 0xa438, 0x0901, 0xa438, 0x8801,
+        0xa438, 0xd700, 0xa438, 0x4040, 0xa438, 0xa801, 0xa438, 0xd701,
+        0xa438, 0x4052, 0xa438, 0xa810, 0xa438, 0xd701, 0xa438, 0x4054,
+        0xa438, 0xa820, 0xa438, 0xd701, 0xa438, 0x4057, 0xa438, 0xa640,
+        0xa438, 0xd704, 0xa438, 0x4046, 0xa438, 0xa840, 0xa438, 0xd706,
+        0xa438, 0x40b5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xae20,
+        0xa438, 0x9503, 0xa438, 0xd401, 0xa438, 0x1000, 0xa438, 0x0fcf,
+        0xa438, 0x1000, 0xa438, 0x0fda, 0xa438, 0x1000, 0xa438, 0x1008,
+        0xa438, 0x1000, 0xa438, 0x0fe3, 0xa438, 0xcc00, 0xa438, 0x80c0,
+        0xa438, 0x8103, 0xa438, 0x83e0, 0xa438, 0xd71e, 0xa438, 0x2318,
+        0xa438, 0x01ae, 0xa438, 0xd704, 0xa438, 0x40bc, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x8302, 0xa438, 0x9503, 0xa438, 0xb801,
+        0xa438, 0xd706, 0xa438, 0x2b59, 0xa438, 0x07f8, 0xa438, 0xd700,
+        0xa438, 0x2109, 0xa438, 0x04ab, 0xa438, 0xa508, 0xa438, 0xcb15,
+        0xa438, 0xd70c, 0xa438, 0x430c, 0xa438, 0x1000, 0xa438, 0x10ca,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xa108, 0xa438, 0x9503,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c1f, 0xa438, 0x0f13,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd70c,
+        0xa438, 0x5fb3, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8f1f,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd70c,
+        0xa438, 0x7f33, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c0f,
+        0xa438, 0x0d00, 0xa438, 0x0c70, 0xa438, 0x0b00, 0xa438, 0xab08,
+        0xa438, 0x9503, 0xa438, 0xd704, 0xa438, 0x3cf1, 0xa438, 0x01f9,
+        0xa438, 0x0c1f, 0xa438, 0x0d11, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x0d0d, 0xa438, 0x0cc0, 0xa438, 0x0d40, 0xa438, 0x1000,
+        0xa438, 0x104f, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xab80,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xa940,
+        0xa438, 0xd700, 0xa438, 0x5f99, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8b80, 0xa438, 0x9503, 0xa438, 0x8940, 0xa438, 0xd700,
+        0xa438, 0x5bbf, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8b08,
+        0xa438, 0x9503, 0xa438, 0xba20, 0xa438, 0xd704, 0xa438, 0x4100,
+        0xa438, 0xd115, 0xa438, 0xd04f, 0xa438, 0xf001, 0xa438, 0x1000,
+        0xa438, 0x1021, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0x0c0f, 0xa438, 0x0d00, 0xa438, 0x0c70,
+        0xa438, 0x0b10, 0xa438, 0xab08, 0xa438, 0x9503, 0xa438, 0xd704,
+        0xa438, 0x3cf1, 0xa438, 0x8178, 0xa438, 0x0c1f, 0xa438, 0x0d11,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d0d, 0xa438, 0x0cc0,
+        0xa438, 0x0d40, 0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xab80, 0xa438, 0x9503, 0xa438, 0x1000,
+        0xa438, 0x1021, 0xa438, 0xd706, 0xa438, 0x5fad, 0xa438, 0xd407,
+        0xa438, 0x1000, 0xa438, 0x0fcf, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8b88, 0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd702, 0xa438, 0x7fa4, 0xa438, 0xd706, 0xa438, 0x61bf,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x0c30, 0xa438, 0x0110,
+        0xa438, 0xa304, 0xa438, 0x9503, 0xa438, 0xd199, 0xa438, 0xd04b,
+        0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0xd704, 0xa438, 0x3cf1, 0xa438, 0x81a5, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d01,
+        0xa438, 0x0cc0, 0xa438, 0x0d40, 0xa438, 0xa420, 0xa438, 0x8720,
+        0xa438, 0x1000, 0xa438, 0x104f, 0xa438, 0x1000, 0xa438, 0x0fda,
+        0xa438, 0xd70c, 0xa438, 0x41ac, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8108, 0xa438, 0x9503, 0xa438, 0x0cc0, 0xa438, 0x0040,
+        0xa438, 0x0c03, 0xa438, 0x0102, 0xa438, 0x0ce0, 0xa438, 0x03e0,
+        0xa438, 0xccce, 0xa438, 0xf008, 0xa438, 0x0cc0, 0xa438, 0x0040,
+        0xa438, 0x0c03, 0xa438, 0x0100, 0xa438, 0x0ce0, 0xa438, 0x0380,
+        0xa438, 0xcc9c, 0xa438, 0x1000, 0xa438, 0x103f, 0xa438, 0x0c03,
+        0xa438, 0x1502, 0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0xcb16,
+        0xa438, 0xd706, 0xa438, 0x6129, 0xa438, 0xd70c, 0xa438, 0x608c,
+        0xa438, 0xd17a, 0xa438, 0xd04a, 0xa438, 0xf006, 0xa438, 0xd17a,
+        0xa438, 0xd04b, 0xa438, 0xf003, 0xa438, 0xd13d, 0xa438, 0xd04b,
+        0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb17, 0xa438, 0x8fc0,
+        0xa438, 0x1000, 0xa438, 0x0fbd, 0xa438, 0xaf40, 0xa438, 0x1000,
+        0xa438, 0x0fbd, 0xa438, 0x0cc0, 0xa438, 0x0f80, 0xa438, 0x1000,
+        0xa438, 0x0fbd, 0xa438, 0xafc0, 0xa438, 0x1000, 0xa438, 0x0fbd,
+        0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd701, 0xa438, 0x652e,
+        0xa438, 0xd700, 0xa438, 0x5db4, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0x8640, 0xa438, 0xa702, 0xa438, 0x9503, 0xa438, 0xa720,
+        0xa438, 0x1000, 0xa438, 0x0fda, 0xa438, 0xa108, 0xa438, 0x1000,
+        0xa438, 0x0fec, 0xa438, 0x8108, 0xa438, 0x1000, 0xa438, 0x0fe3,
+        0xa438, 0xa202, 0xa438, 0xa308, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x8308, 0xa438, 0xcb18,
+        0xa438, 0x1000, 0xa438, 0x10c2, 0xa438, 0x1000, 0xa438, 0x1021,
+        0xa438, 0xd70c, 0xa438, 0x2c60, 0xa438, 0x02bd, 0xa438, 0xff58,
+        0xa438, 0x8f1f, 0xa438, 0x1000, 0xa438, 0x1021, 0xa438, 0xd701,
+        0xa438, 0x7f8e, 0xa438, 0x1000, 0xa438, 0x0fe3, 0xa438, 0xa130,
+        0xa438, 0xaa2f, 0xa438, 0xa2d5, 0xa438, 0xa407, 0xa438, 0xa720,
+        0xa438, 0x8310, 0xa438, 0xa308, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x8308, 0xa438, 0x1800,
+        0xa438, 0x02d2, 0xa436, 0xA10E, 0xa438, 0x017f, 0xa436, 0xA10C,
+        0xa438, 0x0e04, 0xa436, 0xA10A, 0xa438, 0x0c67, 0xa436, 0xA108,
+        0xa438, 0x0f13, 0xa436, 0xA106, 0xa438, 0x0eb1, 0xa436, 0xA104,
+        0xa438, 0x0e79, 0xa436, 0xA102, 0xa438, 0x0b23, 0xa436, 0xA100,
+        0xa438, 0x0908, 0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xb87c,
+        0xa438, 0x8ad8, 0xa436, 0xb87e, 0xa438, 0xaf8a, 0xa438, 0xf0af,
+        0xa438, 0x8af9, 0xa438, 0xaf8d, 0xa438, 0xdaaf, 0xa438, 0x8e1c,
+        0xa438, 0xaf8f, 0xa438, 0x03af, 0xa438, 0x8f06, 0xa438, 0xaf8f,
+        0xa438, 0x06af, 0xa438, 0x8f06, 0xa438, 0x0265, 0xa438, 0xa002,
+        0xa438, 0x8d78, 0xa438, 0xaf23, 0xa438, 0x47a1, 0xa438, 0x0d06,
+        0xa438, 0x028b, 0xa438, 0x05af, 0xa438, 0x225a, 0xa438, 0xaf22,
+        0xa438, 0x66f8, 0xa438, 0xe08a, 0xa438, 0x33a0, 0xa438, 0x0005,
+        0xa438, 0x028b, 0xa438, 0x21ae, 0xa438, 0x0ea0, 0xa438, 0x0105,
+        0xa438, 0x028b, 0xa438, 0xb3ae, 0xa438, 0x06a0, 0xa438, 0x0203,
+        0xa438, 0x028c, 0xa438, 0x9dfc, 0xa438, 0x04f8, 0xa438, 0xfbfa,
+        0xa438, 0xef69, 0xa438, 0xe080, 0xa438, 0x13ad, 0xa438, 0x267e,
+        0xa438, 0xd067, 0xa438, 0xe48a, 0xa438, 0x34e4, 0xa438, 0x8a36,
+        0xa438, 0xe48a, 0xa438, 0x38e4, 0xa438, 0x8a3a, 0xa438, 0xd0ae,
+        0xa438, 0xe48a, 0xa438, 0x35e4, 0xa438, 0x8a37, 0xa438, 0xe48a,
+        0xa438, 0x39e4, 0xa438, 0x8a3b, 0xa438, 0xd000, 0xa438, 0xe48a,
+        0xa438, 0x3ce4, 0xa438, 0x8a3d, 0xa438, 0xe48a, 0xa438, 0x3ee4,
+        0xa438, 0x8a3f, 0xa438, 0xe48a, 0xa438, 0x40e4, 0xa438, 0x8a41,
+        0xa438, 0xe48a, 0xa438, 0x42e4, 0xa438, 0x8a43, 0xa438, 0xe48a,
+        0xa438, 0x44d0, 0xa438, 0x02e4, 0xa438, 0x8a45, 0xa438, 0xd00a,
+        0xa438, 0xe48a, 0xa438, 0x46d0, 0xa438, 0x16e4, 0xa438, 0x8a47,
+        0xa438, 0xd01e, 0xa438, 0xe48a, 0xa438, 0x48d1, 0xa438, 0x02bf,
+        0xa438, 0x8dce, 0xa438, 0x026b, 0xa438, 0xd0d1, 0xa438, 0x0abf,
+        0xa438, 0x8dd1, 0xa438, 0x026b, 0xa438, 0xd0d1, 0xa438, 0x16bf,
+        0xa438, 0x8dd4, 0xa438, 0x026b, 0xa438, 0xd0d1, 0xa438, 0x1ebf,
+        0xa438, 0x8dd7, 0xa438, 0x026b, 0xa438, 0xd002, 0xa438, 0x73ab,
+        0xa438, 0xef47, 0xa438, 0xe585, 0xa438, 0x5de4, 0xa438, 0x855c,
+        0xa438, 0xee8a, 0xa438, 0x3301, 0xa438, 0xae03, 0xa438, 0x0224,
+        0xa438, 0x95ef, 0xa438, 0x96fe, 0xa438, 0xfffc, 0xa438, 0x04f8,
+        0xa438, 0xf9fa, 0xa438, 0xcefa, 0xa438, 0xef69, 0xa438, 0xfb02,
+        0xa438, 0x8dab, 0xa438, 0xad50, 0xa438, 0x2ee1, 0xa438, 0x8a44,
+        0xa438, 0xa104, 0xa438, 0x2bee, 0xa438, 0x8a33, 0xa438, 0x02e1,
+        0xa438, 0x8a45, 0xa438, 0xbf8d, 0xa438, 0xce02, 0xa438, 0x6bd0,
+        0xa438, 0xe18a, 0xa438, 0x46bf, 0xa438, 0x8dd1, 0xa438, 0x026b,
+        0xa438, 0xd0e1, 0xa438, 0x8a47, 0xa438, 0xbf8d, 0xa438, 0xd402,
+        0xa438, 0x6bd0, 0xa438, 0xe18a, 0xa438, 0x48bf, 0xa438, 0x8dd7,
+        0xa438, 0x026b, 0xa438, 0xd0af, 0xa438, 0x8c94, 0xa438, 0xd200,
+        0xa438, 0xbe00, 0xa438, 0x0002, 0xa438, 0x8ca5, 0xa438, 0x12a2,
+        0xa438, 0x04f6, 0xa438, 0xe18a, 0xa438, 0x44a1, 0xa438, 0x0020,
+        0xa438, 0xd129, 0xa438, 0xbf8d, 0xa438, 0xce02, 0xa438, 0x6bd0,
+        0xa438, 0xd121, 0xa438, 0xbf8d, 0xa438, 0xd102, 0xa438, 0x6bd0,
+        0xa438, 0xd125, 0xa438, 0xbf8d, 0xa438, 0xd402, 0xa438, 0x6bd0,
+        0xa438, 0xbf8d, 0xa438, 0xd702, 0xa438, 0x6bd0, 0xa438, 0xae44,
+        0xa438, 0xa101, 0xa438, 0x1ed1, 0xa438, 0x31bf, 0xa438, 0x8dce,
+        0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8dd1, 0xa438, 0x026b,
+        0xa438, 0xd0d1, 0xa438, 0x2dbf, 0xa438, 0x8dd4, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8dd7, 0xa438, 0x026b, 0xa438, 0xd0ae,
+        0xa438, 0x23a1, 0xa438, 0x0220, 0xa438, 0xd139, 0xa438, 0xbf8d,
+        0xa438, 0xce02, 0xa438, 0x6bd0, 0xa438, 0xbf8d, 0xa438, 0xd102,
+        0xa438, 0x6bd0, 0xa438, 0xd13d, 0xa438, 0xbf8d, 0xa438, 0xd402,
+        0xa438, 0x6bd0, 0xa438, 0xd135, 0xa438, 0xbf8d, 0xa438, 0xd702,
+        0xa438, 0x6bd0, 0xa438, 0xae00, 0xa438, 0xe18a, 0xa438, 0x4411,
+        0xa438, 0xe58a, 0xa438, 0x44d0, 0xa438, 0x00e4, 0xa438, 0x8a3c,
+        0xa438, 0xe48a, 0xa438, 0x3de4, 0xa438, 0x8a3e, 0xa438, 0xe48a,
+        0xa438, 0x3fe4, 0xa438, 0x8a40, 0xa438, 0xe48a, 0xa438, 0x41e4,
+        0xa438, 0x8a42, 0xa438, 0xe48a, 0xa438, 0x4302, 0xa438, 0x73ab,
+        0xa438, 0xef47, 0xa438, 0xe585, 0xa438, 0x5de4, 0xa438, 0x855c,
+        0xa438, 0xffef, 0xa438, 0x96fe, 0xa438, 0xc6fe, 0xa438, 0xfdfc,
+        0xa438, 0x0402, 0xa438, 0x2495, 0xa438, 0xee8a, 0xa438, 0x3300,
+        0xa438, 0x04f8, 0xa438, 0xf9fa, 0xa438, 0xfbef, 0xa438, 0x79fb,
+        0xa438, 0xcffb, 0xa438, 0xd300, 0xa438, 0xa200, 0xa438, 0x09bf,
+        0xa438, 0x8dc2, 0xa438, 0x026b, 0xa438, 0xefaf, 0xa438, 0x8cda,
+        0xa438, 0xa201, 0xa438, 0x09bf, 0xa438, 0x8dc5, 0xa438, 0x026b,
+        0xa438, 0xefaf, 0xa438, 0x8cda, 0xa438, 0xa202, 0xa438, 0x09bf,
+        0xa438, 0x8dc8, 0xa438, 0x026b, 0xa438, 0xefaf, 0xa438, 0x8cda,
+        0xa438, 0xbf8d, 0xa438, 0xcb02, 0xa438, 0x6bef, 0xa438, 0xef64,
+        0xa438, 0xbf8a, 0xa438, 0x3c1a, 0xa438, 0x921a, 0xa438, 0x92d8,
+        0xa438, 0x19d9, 0xa438, 0xef74, 0xa438, 0x0273, 0xa438, 0x93ef,
+        0xa438, 0x47bf, 0xa438, 0x8a3c, 0xa438, 0x1a92, 0xa438, 0x1a92,
+        0xa438, 0xdc19, 0xa438, 0xddd1, 0xa438, 0x0011, 0xa438, 0xa1ff,
+        0xa438, 0xfc13, 0xa438, 0xa310, 0xa438, 0xaf02, 0xa438, 0x8d0e,
+        0xa438, 0xffc7, 0xa438, 0xffef, 0xa438, 0x97ff, 0xa438, 0xfefd,
+        0xa438, 0xfc04, 0xa438, 0xf8fa, 0xa438, 0xfbef, 0xa438, 0x79fb,
+        0xa438, 0xcffb, 0xa438, 0xbf8a, 0xa438, 0x3c1a, 0xa438, 0x921a,
+        0xa438, 0x92d8, 0xa438, 0x19d9, 0xa438, 0xef64, 0xa438, 0xbf8a,
+        0xa438, 0x341a, 0xa438, 0x921a, 0xa438, 0x92d8, 0xa438, 0x19d9,
+        0xa438, 0xef74, 0xa438, 0x0273, 0xa438, 0x78a2, 0xa438, 0x0005,
+        0xa438, 0xbe8d, 0xa438, 0xceae, 0xa438, 0x13a2, 0xa438, 0x0105,
+        0xa438, 0xbe8d, 0xa438, 0xd1ae, 0xa438, 0x0ba2, 0xa438, 0x0205,
+        0xa438, 0xbe8d, 0xa438, 0xd4ae, 0xa438, 0x03be, 0xa438, 0x8dd7,
+        0xa438, 0xad50, 0xa438, 0x17bf, 0xa438, 0x8a45, 0xa438, 0x1a92,
+        0xa438, 0x0702, 0xa438, 0x6bef, 0xa438, 0x07dd, 0xa438, 0xef46,
+        0xa438, 0xbf8a, 0xa438, 0x341a, 0xa438, 0x921a, 0xa438, 0x92dc,
+        0xa438, 0x19dd, 0xa438, 0xffc7, 0xa438, 0xffef, 0xa438, 0x97ff,
+        0xa438, 0xfefc, 0xa438, 0x04ee, 0xa438, 0x8a33, 0xa438, 0x00ee,
+        0xa438, 0x8a32, 0xa438, 0x0404, 0xa438, 0xf8fa, 0xa438, 0xef69,
+        0xa438, 0xe080, 0xa438, 0x13ad, 0xa438, 0x2624, 0xa438, 0xd102,
+        0xa438, 0xbf8d, 0xa438, 0xce02, 0xa438, 0x6bd0, 0xa438, 0xd10a,
+        0xa438, 0xbf8d, 0xa438, 0xd102, 0xa438, 0x6bd0, 0xa438, 0xd116,
+        0xa438, 0xbf8d, 0xa438, 0xd402, 0xa438, 0x6bd0, 0xa438, 0xd11e,
+        0xa438, 0xbf8d, 0xa438, 0xd702, 0xa438, 0x6bd0, 0xa438, 0xee8a,
+        0xa438, 0x3300, 0xa438, 0xef96, 0xa438, 0xfefc, 0xa438, 0x04f8,
+        0xa438, 0xfae0, 0xa438, 0x855c, 0xa438, 0xe185, 0xa438, 0x5def,
+        0xa438, 0x64d0, 0xa438, 0x00e1, 0xa438, 0x8a32, 0xa438, 0xef74,
+        0xa438, 0x0273, 0xa438, 0xc6fe, 0xa438, 0xfc04, 0xa438, 0xf0b2,
+        0xa438, 0x02f0, 0xa438, 0xb282, 0xa438, 0xf0b3, 0xa438, 0x02f0,
+        0xa438, 0xb382, 0xa438, 0x50ac, 0xa438, 0xd450, 0xa438, 0xacd6,
+        0xa438, 0xb6ac, 0xa438, 0xd4b6, 0xa438, 0xacd6, 0xa438, 0xbf8e,
+        0xa438, 0x0d02, 0xa438, 0x6bd0, 0xa438, 0xd0ff, 0xa438, 0xd1fe,
+        0xa438, 0xbf8e, 0xa438, 0x1002, 0xa438, 0x6bd0, 0xa438, 0xd004,
+        0xa438, 0xd14d, 0xa438, 0xbf8e, 0xa438, 0x1302, 0xa438, 0x6bd0,
+        0xa438, 0xd0fc, 0xa438, 0xd1c6, 0xa438, 0xbf8e, 0xa438, 0x1602,
+        0xa438, 0x6bd0, 0xa438, 0xd009, 0xa438, 0xd146, 0xa438, 0xbf8e,
+        0xa438, 0x1902, 0xa438, 0x6bd0, 0xa438, 0xef13, 0xa438, 0xaf2d,
+        0xa438, 0xbdf0, 0xa438, 0xac1c, 0xa438, 0xf0ac, 0xa438, 0x2af0,
+        0xa438, 0xac2c, 0xa438, 0xf0ac, 0xa438, 0x2ef0, 0xa438, 0xac30,
+        0xa438, 0xbf8e, 0xa438, 0xf102, 0xa438, 0x6bef, 0xa438, 0xac28,
+        0xa438, 0x70bf, 0xa438, 0x8eeb, 0xa438, 0x026b, 0xa438, 0xefac,
+        0xa438, 0x2867, 0xa438, 0xbf8e, 0xa438, 0xee02, 0xa438, 0x6bef,
+        0xa438, 0xad28, 0xa438, 0x5bbf, 0xa438, 0x8ff2, 0xa438, 0xd8bf,
+        0xa438, 0x8ff3, 0xa438, 0xd9bf, 0xa438, 0x8ef4, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8ff0, 0xa438, 0xd8bf, 0xa438, 0x8ff1,
+        0xa438, 0xd9bf, 0xa438, 0x8ef7, 0xa438, 0x026b, 0xa438, 0xd0bf,
+        0xa438, 0x8fee, 0xa438, 0xd8bf, 0xa438, 0x8fef, 0xa438, 0xd9bf,
+        0xa438, 0x8efa, 0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8fec,
+        0xa438, 0xd8bf, 0xa438, 0x8fed, 0xa438, 0xd9bf, 0xa438, 0x8efd,
+        0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8fea, 0xa438, 0xd8bf,
+        0xa438, 0x8feb, 0xa438, 0xd9bf, 0xa438, 0x8f00, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8fe8, 0xa438, 0xd8bf, 0xa438, 0x8fe9,
+        0xa438, 0xd9bf, 0xa438, 0x8e0d, 0xa438, 0x026b, 0xa438, 0xd01f,
+        0xa438, 0x00e1, 0xa438, 0x86ee, 0xa438, 0x1b64, 0xa438, 0xaf3d,
+        0xa438, 0x7abf, 0xa438, 0x8ffe, 0xa438, 0xd8bf, 0xa438, 0x8fff,
+        0xa438, 0xd9bf, 0xa438, 0x8ef4, 0xa438, 0x026b, 0xa438, 0xd0bf,
+        0xa438, 0x8ffc, 0xa438, 0xd8bf, 0xa438, 0x8ffd, 0xa438, 0xd9bf,
+        0xa438, 0x8ef7, 0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8ffa,
+        0xa438, 0xd8bf, 0xa438, 0x8ffb, 0xa438, 0xd9bf, 0xa438, 0x8efa,
+        0xa438, 0x026b, 0xa438, 0xd0bf, 0xa438, 0x8ff8, 0xa438, 0xd8bf,
+        0xa438, 0x8ff9, 0xa438, 0xd9bf, 0xa438, 0x8efd, 0xa438, 0x026b,
+        0xa438, 0xd0bf, 0xa438, 0x8ff6, 0xa438, 0xd8bf, 0xa438, 0x8ff7,
+        0xa438, 0xd9bf, 0xa438, 0x8f00, 0xa438, 0x026b, 0xa438, 0xd0bf,
+        0xa438, 0x8ff4, 0xa438, 0xd8bf, 0xa438, 0x8ff5, 0xa438, 0xd9bf,
+        0xa438, 0x8e0d, 0xa438, 0x026b, 0xa438, 0xd0ae, 0xa438, 0xa766,
+        0xa438, 0xac5c, 0xa438, 0xbbac, 0xa438, 0x5c99, 0xa438, 0xac5c,
+        0xa438, 0xf0ac, 0xa438, 0x26f0, 0xa438, 0xac24, 0xa438, 0xf0ac,
+        0xa438, 0x22f0, 0xa438, 0xac20, 0xa438, 0xf0ac, 0xa438, 0x1eaf,
+        0xa438, 0x44f8, 0xa436, 0xb85e, 0xa438, 0x2344, 0xa436, 0xb860,
+        0xa438, 0x2254, 0xa436, 0xb862, 0xa438, 0x2DB5, 0xa436, 0xb864,
+        0xa438, 0x3D6C, 0xa436, 0xb886, 0xa438, 0x44ED, 0xa436, 0xb888,
+        0xa438, 0xffff, 0xa436, 0xb88a, 0xa438, 0xffff, 0xa436, 0xb88c,
+        0xa438, 0xffff, 0xa436, 0xb838, 0xa438, 0x001f, 0xb820, 0x0010,
+        0xa436, 0x87ad, 0xa438, 0xaf87, 0xa438, 0xc5af, 0xa438, 0x87e4,
+        0xa438, 0xaf8a, 0xa438, 0x3daf, 0xa438, 0x8a62, 0xa438, 0xaf8a,
+        0xa438, 0x62af, 0xa438, 0x8a62, 0xa438, 0xaf8a, 0xa438, 0x62af,
+        0xa438, 0x8a62, 0xa438, 0x2810, 0xa438, 0x0d01, 0xa438, 0xe484,
+        0xa438, 0xbf29, 0xa438, 0x100d, 0xa438, 0x11e5, 0xa438, 0x84c0,
+        0xa438, 0x2a10, 0xa438, 0x0d21, 0xa438, 0xe684, 0xa438, 0xc12b,
+        0xa438, 0x100d, 0xa438, 0x31e7, 0xa438, 0x84c2, 0xa438, 0xaf3f,
+        0xa438, 0x7cf8, 0xa438, 0xe080, 0xa438, 0x4cac, 0xa438, 0x222c,
+        0xa438, 0xe080, 0xa438, 0x40ad, 0xa438, 0x2232, 0xa438, 0xbf8a,
+        0xa438, 0x2502, 0xa438, 0x6752, 0xa438, 0xad29, 0xa438, 0x0502,
+        0xa438, 0x8827, 0xa438, 0xae0d, 0xa438, 0xad28, 0xa438, 0x0502,
+        0xa438, 0x8961, 0xa438, 0xae05, 0xa438, 0x0214, 0xa438, 0x04ae,
+        0xa438, 0x00e0, 0xa438, 0x8040, 0xa438, 0xac22, 0xa438, 0x1102,
+        0xa438, 0x13e1, 0xa438, 0xae0c, 0xa438, 0x0288, 0xa438, 0x7c02,
+        0xa438, 0x8a10, 0xa438, 0x0214, 0xa438, 0x2502, 0xa438, 0x1404,
+        0xa438, 0xfcaf, 0xa438, 0x13c6, 0xa438, 0xf8f8, 0xa438, 0xccf9,
+        0xa438, 0xfaef, 0xa438, 0x69fb, 0xa438, 0xe080, 0xa438, 0x18ad,
+        0xa438, 0x223b, 0xa438, 0xbf8a, 0xa438, 0x2b02, 0xa438, 0x6752,
+        0xa438, 0xad28, 0xa438, 0x32bf, 0xa438, 0x8a28, 0xa438, 0x026f,
+        0xa438, 0x17ee, 0xa438, 0x8ff3, 0xa438, 0x00bf, 0xa438, 0x6854,
+        0xa438, 0x0267, 0xa438, 0x52ad, 0xa438, 0x281f, 0xa438, 0xbf68,
+        0xa438, 0x5d02, 0xa438, 0x6752, 0xa438, 0xad28, 0xa438, 0x16e0,
+        0xa438, 0x8ff4, 0xa438, 0xe18f, 0xa438, 0xf502, 0xa438, 0x8891,
+        0xa438, 0xad50, 0xa438, 0x0abf, 0xa438, 0x8a28, 0xa438, 0x026f,
+        0xa438, 0x20ee, 0xa438, 0x8ff3, 0xa438, 0x0102, 0xa438, 0x1404,
+        0xa438, 0xffef, 0xa438, 0x96fe, 0xa438, 0xfdc4, 0xa438, 0xfcfc,
+        0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x59e0, 0xa438, 0x8018,
+        0xa438, 0xad22, 0xa438, 0x06bf, 0xa438, 0x8a28, 0xa438, 0x026f,
+        0xa438, 0x17ef, 0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xf9ef, 0xa438, 0x59fa, 0xa438, 0xface, 0xa438, 0xe48f,
+        0xa438, 0xfee5, 0xa438, 0x8fff, 0xa438, 0xbf6e, 0xa438, 0x1b02,
+        0xa438, 0x6f20, 0xa438, 0xbf6e, 0xa438, 0x1802, 0xa438, 0x6f17,
+        0xa438, 0xd102, 0xa438, 0xbf6e, 0xa438, 0x1202, 0xa438, 0x6733,
+        0xa438, 0xbf6e, 0xa438, 0x1502, 0xa438, 0x6f17, 0xa438, 0xbe00,
+        0xa438, 0x00cc, 0xa438, 0xbf69, 0xa438, 0xcb02, 0xa438, 0x6733,
+        0xa438, 0xbf69, 0xa438, 0xce02, 0xa438, 0x6f17, 0xa438, 0xbf69,
+        0xa438, 0xce02, 0xa438, 0x6f20, 0xa438, 0xbf69, 0xa438, 0xd102,
+        0xa438, 0x6752, 0xa438, 0xad28, 0xa438, 0xf70c, 0xa438, 0x81bf,
+        0xa438, 0x8ff6, 0xa438, 0x1a98, 0xa438, 0xef59, 0xa438, 0xbf69,
+        0xa438, 0xd402, 0xa438, 0x6752, 0xa438, 0xef95, 0xa438, 0xdc19,
+        0xa438, 0xdd0d, 0xa438, 0x8118, 0xa438, 0xa800, 0xa438, 0x04c9,
+        0xa438, 0xbf69, 0xa438, 0xce02, 0xa438, 0x6f17, 0xa438, 0xe08f,
+        0xa438, 0xfce1, 0xa438, 0x8ffd, 0xa438, 0xef74, 0xa438, 0xe08f,
+        0xa438, 0xfae1, 0xa438, 0x8ffb, 0xa438, 0xef64, 0xa438, 0x026e,
+        0xa438, 0x57ad, 0xa438, 0x5008, 0xa438, 0xe08f, 0xa438, 0xfce1,
+        0xa438, 0x8ffd, 0xa438, 0xae06, 0xa438, 0xe08f, 0xa438, 0xfae1,
+        0xa438, 0x8ffb, 0xa438, 0xe28f, 0xa438, 0xf8e3, 0xa438, 0x8ff9,
+        0xa438, 0xef75, 0xa438, 0xe28f, 0xa438, 0xf6e3, 0xa438, 0x8ff7,
+        0xa438, 0xef65, 0xa438, 0x026e, 0xa438, 0x57ad, 0xa438, 0x5008,
+        0xa438, 0xe28f, 0xa438, 0xf8e3, 0xa438, 0x8ff9, 0xa438, 0xae06,
+        0xa438, 0xe28f, 0xa438, 0xf6e3, 0xa438, 0x8ff7, 0xa438, 0x1b45,
+        0xa438, 0xad27, 0xa438, 0x05d7, 0xa438, 0x0000, 0xa438, 0xae0d,
+        0xa438, 0xef74, 0xa438, 0xe08f, 0xa438, 0xfee1, 0xa438, 0x8fff,
+        0xa438, 0xef64, 0xa438, 0x026e, 0xa438, 0x57c6, 0xa438, 0xfefe,
+        0xa438, 0xef95, 0xa438, 0xfdfd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xfaef, 0xa438, 0x69fb, 0xa438, 0xe080, 0xa438, 0x18ac,
+        0xa438, 0x2103, 0xa438, 0xaf8a, 0xa438, 0x06bf, 0xa438, 0x8a2b,
+        0xa438, 0xac21, 0xa438, 0x03af, 0xa438, 0x8a06, 0xa438, 0xbf8a,
+        0xa438, 0x2802, 0xa438, 0x6f17, 0xa438, 0xee8f, 0xa438, 0xee00,
+        0xa438, 0xee8f, 0xa438, 0xed00, 0xa438, 0xbf8a, 0xa438, 0x2e02,
+        0xa438, 0x6752, 0xa438, 0xad28, 0xa438, 0x03af, 0xa438, 0x8a06,
+        0xa438, 0xe28f, 0xa438, 0xefe3, 0xa438, 0x8ff0, 0xa438, 0xbf68,
+        0xa438, 0x5102, 0xa438, 0x6752, 0xa438, 0xac28, 0xa438, 0x11e2,
+        0xa438, 0x8ff1, 0xa438, 0xe38f, 0xa438, 0xf2bf, 0xa438, 0x6848,
+        0xa438, 0x0267, 0xa438, 0x52ac, 0xa438, 0x2802, 0xa438, 0xae53,
+        0xa438, 0xbf68, 0xa438, 0x5a02, 0xa438, 0x6752, 0xa438, 0xad28,
+        0xa438, 0x0aef, 0xa438, 0x4502, 0xa438, 0x8891, 0xa438, 0xac50,
+        0xa438, 0x38ae, 0xa438, 0x40bf, 0xa438, 0x8a31, 0xa438, 0x0267,
+        0xa438, 0x52ef, 0xa438, 0x31bf, 0xa438, 0x8a34, 0xa438, 0x0267,
+        0xa438, 0x520c, 0xa438, 0x311e, 0xa438, 0x31bf, 0xa438, 0x8a37,
+        0xa438, 0x0267, 0xa438, 0x520c, 0xa438, 0x311e, 0xa438, 0x31bf,
+        0xa438, 0x8a3a, 0xa438, 0x0267, 0xa438, 0x520c, 0xa438, 0x311e,
+        0xa438, 0x31e7, 0xa438, 0x8fee, 0xa438, 0xa30c, 0xa438, 0x02ae,
+        0xa438, 0x08a3, 0xa438, 0x0e02, 0xa438, 0xae03, 0xa438, 0xa30d,
+        0xa438, 0x0aee, 0xa438, 0x8fed, 0xa438, 0x01bf, 0xa438, 0x8a28,
+        0xa438, 0x026f, 0xa438, 0x2002, 0xa438, 0x1404, 0xa438, 0xffef,
+        0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xfaef,
+        0xa438, 0x69e0, 0xa438, 0x8018, 0xa438, 0xad21, 0xa438, 0x06bf,
+        0xa438, 0x8a28, 0xa438, 0x026f, 0xa438, 0x17ef, 0xa438, 0x96fe,
+        0xa438, 0xfc04, 0xa438, 0xf8a4, 0xa438, 0xb677, 0xa438, 0xa4b6,
+        0xa438, 0x22a4, 0xa438, 0x4222, 0xa438, 0xa668, 0xa438, 0x00b2,
+        0xa438, 0x3e00, 0xa438, 0xb2be, 0xa438, 0x00b3, 0xa438, 0x3e00,
+        0xa438, 0xb3be, 0xa438, 0xd10f, 0xa438, 0xbf8a, 0xa438, 0x5c02,
+        0xa438, 0x6733, 0xa438, 0xbf8a, 0xa438, 0x5f02, 0xa438, 0x6733,
+        0xa438, 0xbf8a, 0xa438, 0x5c02, 0xa438, 0x6f17, 0xa438, 0xbf8a,
+        0xa438, 0x5f02, 0xa438, 0x6f17, 0xa438, 0x1f00, 0xa438, 0xaf3d,
+        0xa438, 0x0c30, 0xa438, 0xa85a, 0xa438, 0xfcad, 0xa438, 0x0e00,
+        0xa436, 0xb818, 0xa438, 0x3f31, 0xa436, 0xb81a, 0xa438, 0x13a4,
+        0xa436, 0xb81c, 0xa438, 0x3d0a, 0xa436, 0xb81e, 0xa438, 0xffff,
+        0xa436, 0xb850, 0xa438, 0xffff, 0xa436, 0xb852, 0xa438, 0xffff,
+        0xa436, 0xb878, 0xa438, 0xffff, 0xa436, 0xb884, 0xa438, 0xffff,
+        0xa436, 0xb832, 0xa438, 0x0007, 0xa436, 0x84cf, 0xa438, 0x0101,
+        0xa466, 0x0002, 0xa436, 0x86a7, 0xa438, 0x0000, 0xa436, 0x0000,
+        0xa438, 0x0000, 0xa436, 0xB82E, 0xa438, 0x0000, 0xa436, 0x8023,
+        0xa438, 0x0000, 0xa436, 0x801E, 0xa438, 0x0023, 0xb820, 0x0000,
+        0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_1_2[] = {
+        0xB87C, 0x8a32, 0xB87E, 0x0400, 0xB87C, 0x8376, 0xB87E, 0x0300,
+        0xce00, 0x6CAF, 0xB87C, 0x8301, 0xB87E, 0x1133, 0xB87C, 0x8105,
+        0xB87E, 0xa000, 0xB87C, 0x8148, 0xB87E, 0xa000, 0xa436, 0x81d8,
+        0xa438, 0x5865, 0xacf8, 0xCCC0, 0xac90, 0x52B0, 0xad2C, 0x8000,
+        0xB87C, 0x83e6, 0xB87E, 0x4A0E, 0xB87C, 0x83d2, 0xB87E, 0x0A0E,
+        0xB87C, 0x80a0, 0xB87E, 0xB8B6, 0xB87C, 0x805e, 0xB87E, 0xB8B6,
+        0xB87C, 0x8057, 0xB87E, 0x305A, 0xB87C, 0x8099, 0xB87E, 0x305A,
+        0xB87C, 0x8052, 0xB87E, 0x3333, 0xB87C, 0x8094, 0xB87E, 0x3333,
+        0xB87C, 0x807F, 0xB87E, 0x7975, 0xB87C, 0x803D, 0xB87E, 0x7975,
+        0xB87C, 0x8036, 0xB87E, 0x305A, 0xB87C, 0x8078, 0xB87E, 0x305A,
+        0xB87C, 0x8031, 0xB87E, 0x3335, 0xB87C, 0x8073, 0xB87E, 0x3335,
+        0xa436, 0x81D8, 0xa438, 0x5865, 0xB87C, 0x867c, 0xB87E, 0x0617,
+        0xad94, 0x0092, 0xB87C, 0x89B1, 0xB87E, 0x5050, 0xB87C, 0x86E0,
+        0xB87E, 0x809A, 0xB87C, 0x86E2, 0xB87E, 0xB34D, 0xB87C, 0x8FD2,
+        0xB87E, 0x004B, 0xB87C, 0x8691, 0xB87E, 0x007D, 0xB87E, 0x00AF,
+        0xB87E, 0x00E1, 0xB87E, 0x00FF, 0xB87C, 0x867F, 0xB87E, 0x0201,
+        0xB87E, 0x0201, 0xB87E, 0x0201, 0xB87E, 0x0201, 0xB87E, 0x0201,
+        0xB87E, 0x0201, 0xB87C, 0x86DA, 0xB87E, 0xCDCD, 0xB87E, 0xE6CD,
+        0xB87E, 0xCDCD, 0xB87C, 0x8FE8, 0xB87E, 0x0368, 0xB87E, 0x033F,
+        0xB87E, 0x1046, 0xB87E, 0x147D, 0xB87E, 0x147D, 0xB87E, 0x147D,
+        0xB87E, 0x0368, 0xB87E, 0x033F, 0xB87E, 0x1046, 0xB87E, 0x147D,
+        0xB87E, 0x147D, 0xB87E, 0x147D, 0xa436, 0x80dd, 0xa438, 0xf0AB,
+        0xa436, 0x80df, 0xa438, 0xC009, 0xa436, 0x80e7, 0xa438, 0x401E,
+        0xa436, 0x80e1, 0xa438, 0x120A, 0xa436, 0x86f2, 0xa438, 0x5094,
+        0xa436, 0x8701, 0xa438, 0x5094, 0xa436, 0x80f1, 0xa438, 0x30CC,
+        0xa436, 0x80f3, 0xa438, 0x0001, 0xa436, 0x80f5, 0xa438, 0x330B,
+        0xa436, 0x80f8, 0xa438, 0xCB76, 0xa436, 0x8105, 0xa438, 0xf0D3,
+        0xa436, 0x8107, 0xa438, 0x0002, 0xa436, 0x8109, 0xa438, 0xff0B,
+        0xa436, 0x810c, 0xa438, 0xC86D, 0xB87C, 0x8a32, 0xB87E, 0x0400,
+        0xa6f8, 0x0000, 0xa6f8, 0x0000, 0xa436, 0x81bc, 0xa438, 0x1300,
+        0xa846, 0x2410, 0xa86A, 0x0801, 0xa85C, 0x9680, 0xa436, 0x841D,
+        0xa438, 0x4A28, 0xa436, 0x8016, 0xa438, 0xBE05, 0xBF9C, 0x004A,
+        0xBF96, 0x41FA, 0xBF9A, 0xDC81, 0xa436, 0x8018, 0xa438, 0x0700,
+        0xa436, 0x8ff4, 0xa438, 0x01AE, 0xa436, 0x8fef, 0xa438, 0x0172,
+        0xa438, 0x00dc, 0xc842, 0x0002, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8126a_1_3[] = {
+        0xb892, 0x0000, 0xB88E, 0xC236, 0xB890, 0x1A1C, 0xB88E, 0xC238,
+        0xB890, 0x1C1C, 0xB890, 0x1C1C, 0xB890, 0x2D2D, 0xB890, 0x2D2D,
+        0xB890, 0x2D2A, 0xB890, 0x2A2A, 0xB890, 0x2A2A, 0xB890, 0x2A19,
+        0xB88E, 0xC272, 0xB890, 0x8484, 0xB890, 0x8484, 0xB890, 0x84B4,
+        0xB890, 0xB4B4, 0xB890, 0xB4B4, 0xB890, 0xF8F8, 0xB890, 0xF8F8,
+        0xB890, 0xF8F8, 0xB88E, 0xC000, 0xB890, 0x0303, 0xB890, 0x0405,
+        0xB890, 0x0608, 0xB890, 0x0A0B, 0xB890, 0x0E11, 0xB890, 0x1519,
+        0xB890, 0x2028, 0xB890, 0x3503, 0xB890, 0x0304, 0xB890, 0x0405,
+        0xB890, 0x0606, 0xB890, 0x0708, 0xB890, 0x090A, 0xB890, 0x0B0D,
+        0xB890, 0x0F11, 0xB890, 0x1315, 0xB890, 0x181A, 0xB890, 0x2029,
+        0xB890, 0x2F36, 0xB890, 0x3D43, 0xB890, 0x0101, 0xB890, 0x0102,
+        0xB890, 0x0202, 0xB890, 0x0303, 0xB890, 0x0405, 0xB890, 0x0607,
+        0xB890, 0x090A, 0xB890, 0x0C0E, 0xB88E, 0xC038, 0xB890, 0x6AE1,
+        0xB890, 0x8E6B, 0xB890, 0xA767, 0xB890, 0x01EF, 0xB890, 0x5A63,
+        0xB890, 0x2B99, 0xB890, 0x7F5D, 0xB890, 0x361F, 0xB890, 0xA127,
+        0xB890, 0xB558, 0xB890, 0x11C3, 0xB890, 0x7D85, 0xB890, 0xBAC5,
+        0xB890, 0xE691, 0xB890, 0x8F79, 0xB890, 0x3164, 0xB890, 0x3293,
+        0xB890, 0xB80D, 0xB890, 0xE2B7, 0xB890, 0x0D62, 0xB890, 0x4F85,
+        0xB890, 0xC919, 0xB890, 0x78F3, 0xB890, 0x77FF, 0xB890, 0xBD9E,
+        0xB890, 0x69D6, 0xB890, 0x6DA4, 0xB890, 0x0CC5, 0xB88E, 0xC1D2,
+        0xB890, 0x2425, 0xB890, 0x2627, 0xB890, 0x2829, 0xB890, 0x2A2B,
+        0xB890, 0x2C2D, 0xB890, 0x2E2F, 0xB890, 0x3031, 0xB890, 0x3233,
+        0xB890, 0x2323, 0xB890, 0x2424, 0xB890, 0x2525, 0xB890, 0x2626,
+        0xB890, 0x2727, 0xB890, 0x2828, 0xB890, 0x2929, 0xB890, 0x2A2A,
+        0xB890, 0x2B2C, 0xB890, 0x2C2D, 0xB890, 0x2D2E, 0xB890, 0x2E2F,
+        0xB890, 0x2F30, 0xB890, 0x1A1B, 0xB890, 0x1D1E, 0xB890, 0x1F20,
+        0xB890, 0x2123, 0xB890, 0x2425, 0xB890, 0x2628, 0xB890, 0x292A,
+        0xB890, 0x2B2C, 0xB890, 0x2E12, 0xB88E, 0xC09A, 0xB890, 0xD3D3,
+        0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xB890, 0xD3D3,
+        0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xB890, 0xD3D3, 0xFFFF, 0xFFFF
+};
+
 static void
 rtl8125_real_set_phy_mcu_8125b_1(struct net_device *dev)
 {
@@ -9265,6 +10247,57 @@ rtl8125_set_phy_mcu_8125b_2(struct net_d
 }
 
 static void
+rtl8125_real_set_phy_mcu_8126a_1_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_1_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_1_1)
+                                    );
+}
+
+static void
+rtl8125_real_set_phy_mcu_8126a_1_2(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_1_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_1_2)
+                                    );
+}
+
+static void
+rtl8125_real_set_phy_mcu_8126a_1_3(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8126a_1_3,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8126a_1_3)
+                                    );
+}
+
+static void
+rtl8125_set_phy_mcu_8126a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8126a_1_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8126a_1_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8126a_1_3(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
 rtl8125_init_hw_phy_mcu(struct net_device *dev)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
@@ -9294,6 +10327,9 @@ rtl8125_init_hw_phy_mcu(struct net_devic
         case CFG_METHOD_7:
                 rtl8125_set_phy_mcu_8125b_2(dev);
                 break;
+        case CFG_METHOD_8:
+                rtl8125_set_phy_mcu_8126a_1(dev);
+                break;
         }
 
         if (require_disable_phy_disable_mode)
@@ -9800,6 +10836,9 @@ rtl8125_hw_phy_config_8125a_2(struct net
         }
 
 
+        SetEthPhyOcpBit(tp, 0xA424, BIT_3);
+
+
         if (aspm) {
                 if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
                         rtl8125_enable_phy_aldps(tp);
@@ -10174,6 +11213,9 @@ rtl8125_hw_phy_config_8125b_2(struct net
                                 BIT_15 | BIT_14 | BIT_12 | BIT_11
                                );
 
+
+        SetEthPhyOcpBit(tp, 0xA424, BIT_3);
+
         /*
         mdio_direct_write_phy_ocp(tp, 0xBFA0, 0xD70D);
         mdio_direct_write_phy_ocp(tp, 0xBFA2, 0x4100);
@@ -10194,6 +11236,22 @@ rtl8125_hw_phy_config_8125b_2(struct net
 }
 
 static void
+rtl8125_hw_phy_config_8126a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        SetEthPhyOcpBit(tp, 0xA442, BIT_11);
+
+        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, tp->eee.tx_lpi_timer);
+
+        if (aspm) {
+                if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                        rtl8125_enable_phy_aldps(tp);
+                }
+        }
+}
+
+static void
 rtl8125_hw_phy_config(struct net_device *dev)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
@@ -10227,6 +11285,9 @@ rtl8125_hw_phy_config(struct net_device
         case CFG_METHOD_7:
                 rtl8125_hw_phy_config_8125b_2(dev);
                 break;
+        case CFG_METHOD_8:
+                rtl8125_hw_phy_config_8126a_1(dev);
+                break;
         }
 
         //legacy force mode(Chap 22)
@@ -10237,6 +11298,7 @@ rtl8125_hw_phy_config(struct net_device
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
         default:
                 rtl8125_mdio_write(tp, 0x1F, 0x0A5B);
                 rtl8125_clear_eth_phy_bit(tp, 0x12, BIT_15);
@@ -10355,6 +11417,7 @@ rtl8125_get_bios_setting(struct net_devi
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->bios_setting = RTL_R32(tp, TimeInt2);
                 break;
         }
@@ -10372,6 +11435,7 @@ rtl8125_set_bios_setting(struct net_devi
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W32(tp, TimeInt2, tp->bios_setting);
                 break;
         }
@@ -10389,8 +11453,13 @@ rtl8125_setup_mqs_reg(struct rtl8125_pri
         }
 
         for (i = 0; i < R8125_MAX_TX_QUEUES; i++) {
-                tp->tx_ring[i].hw_clo_ptr_reg = (u16)(HW_CLO_PTR0_8125 + i * 4);
-                tp->tx_ring[i].sw_tail_ptr_reg = (u16)(SW_TAIL_PTR0_8125 + i * 4);
+                if (tp->HwSuppTxNoCloseVer == 4) {
+                        tp->tx_ring[i].hw_clo_ptr_reg = (u16)(HW_CLO_PTR0_8126 + i * 4);
+                        tp->tx_ring[i].sw_tail_ptr_reg = (u16)(SW_TAIL_PTR0_8126 + i * 4);
+                } else {
+                        tp->tx_ring[i].hw_clo_ptr_reg = (u16)(HW_CLO_PTR0_8125 + i * 4);
+                        tp->tx_ring[i].sw_tail_ptr_reg = (u16)(SW_TAIL_PTR0_8125 + i * 4);
+                }
         }
 
         //rx
@@ -10439,6 +11508,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwPkgDet = rtl8125_mac_ocp_read(tp, 0xDC00);
                 tp->HwPkgDet = (tp->HwPkgDet >> 3) & 0x07;
                 break;
@@ -10454,6 +11524,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppNowIsOobVer = 1;
                 break;
         }
@@ -10465,6 +11536,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwPcieSNOffset = 0x16C;
                 break;
         }
@@ -10511,7 +11583,7 @@ rtl8125_init_software_variable(struct ne
                 eee_enable = 0;
         }
 
-        if	(HW_DASH_SUPPORT_TYPE_3(tp))
+        if (HW_DASH_SUPPORT_TYPE_3(tp))
                 tp->cmac_ioaddr = tp->mapped_cmac_ioaddr;
 
         if (aspm) {
@@ -10522,6 +11594,7 @@ rtl8125_init_software_variable(struct ne
                 case CFG_METHOD_5:
                 case CFG_METHOD_6:
                 case CFG_METHOD_7:
+                case CFG_METHOD_8:
                         tp->org_pci_offset_99 = rtl8125_csi_fun0_read_byte(tp, 0x99);
                         tp->org_pci_offset_99 &= ~(BIT_5|BIT_6);
                         break;
@@ -10538,6 +11611,9 @@ rtl8125_init_software_variable(struct ne
                 case CFG_METHOD_7:
                         tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x214);
                         break;
+                case CFG_METHOD_8:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x22c);
+                        break;
                 }
         }
 
@@ -10551,11 +11627,27 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
         default:
                 tp->use_timer_interrrupt = TRUE;
                 break;
         }
 
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+                tp->HwSuppMaxPhyLinkSpeed = 2500;
+                break;
+        case CFG_METHOD_8:
+                tp->HwSuppMaxPhyLinkSpeed = 5000;
+                break;
+        default:
+                tp->HwSuppMaxPhyLinkSpeed = 1000;
+                break;
+        }
+
         if (timer_count == 0 || tp->mcfg == CFG_METHOD_DEFAULT)
                 tp->use_timer_interrrupt = FALSE;
 
@@ -10566,6 +11658,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppMagicPktVer = WAKEUP_MAGIC_PACKET_V3;
                 break;
         default:
@@ -10580,6 +11673,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppLinkChgWakeUpVer = 3;
                 break;
         }
@@ -10590,6 +11684,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppD0SpeedUpVer = 1;
                 break;
         }
@@ -10601,6 +11696,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppCheckPhyDisableModeVer = 3;
                 break;
         }
@@ -10614,8 +11710,18 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_7:
                 tp->HwSuppTxNoCloseVer = 3;
                 break;
+        case CFG_METHOD_8:
+                tp->HwSuppTxNoCloseVer = 4;
+                break;
         }
 
+        if (tp->HwSuppTxNoCloseVer == 4)
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3;
+        else if (tp->HwSuppTxNoCloseVer == 3)
+                tp->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2;
+        else
+                tx_no_close_enable = 0;
+
         if (tp->HwSuppTxNoCloseVer > 0 && tx_no_close_enable == 1)
                 tp->EnableTxNoClose = TRUE;
 
@@ -10642,6 +11748,9 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_7:
                 tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_5;
                 break;
+        case CFG_METHOD_8:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_8;
+                break;
         }
 
         if (tp->HwIcVerUnknown) {
@@ -10665,6 +11774,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppMacMcuVer = 2;
                 break;
         }
@@ -10676,6 +11786,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->MacMcuPageSize = RTL8125_MAC_MCU_PAGE_SIZE;
                 break;
         }
@@ -10684,6 +11795,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppNumTxQueues = 2;
                 tp->HwSuppNumRxQueues = 4;
                 break;
@@ -10704,6 +11816,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppRssVer = 5;
                 tp->HwSuppIndirTblEntries = 128;
                 break;
@@ -10750,6 +11863,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppIsrVer = 2;
                 break;
         default:
@@ -10799,6 +11913,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppIntMitiVer = 4;
                 break;
         }
@@ -10810,6 +11925,7 @@ rtl8125_init_software_variable(struct ne
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->HwSuppExtendTallyCounterVer = 1;
                 break;
         }
@@ -10846,15 +11962,17 @@ rtl8125_init_software_variable(struct ne
         tp->wol_opts = rtl8125_get_hw_wol(tp);
         tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
 
-        if (tp->mcfg == CFG_METHOD_6 || tp->mcfg == CFG_METHOD_7)
-                rtl8125_link_option_giga((u8*)&autoneg_mode, (u32*)&speed_mode, (u8*)&duplex_mode, (u32*)&advertising_mode);
-        else
+        if (HW_SUPP_PHY_LINK_SPEED_2500M(tp))
                 rtl8125_link_option((u8*)&autoneg_mode, (u32*)&speed_mode, (u8*)&duplex_mode, (u32*)&advertising_mode);
+        else
+                rtl8125_link_option_giga((u8*)&autoneg_mode, (u32*)&speed_mode, (u8*)&duplex_mode, (u32*)&advertising_mode);
 
         tp->autoneg = autoneg_mode;
         tp->speed = speed_mode;
         tp->duplex = duplex_mode;
         tp->advertising = advertising_mode;
+        if (HW_SUPP_PHY_LINK_SPEED_5000M(tp))
+                tp->advertising |= RTK_ADVERTISED_5000baseX_Full;
         tp->fcpause = rtl8125_fc_full;
 
         tp->max_jumbo_frame_size = rtl_chip_info[tp->chipset].jumbo_frame_sz;
@@ -10873,6 +11991,7 @@ rtl8125_init_software_variable(struct ne
                 switch (tp->mcfg) {
                 case CFG_METHOD_4:
                 case CFG_METHOD_5:
+                case CFG_METHOD_8:
                         eee->supported |= SUPPORTED_2500baseX_Full;
                         break;
                 }
@@ -10927,32 +12046,6 @@ rtl8125_hw_address_set(struct net_device
 #endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
 }
 
-/*
- * Create an ethernet address from the system serial number.
- */
-/*
-static int __init ethernet_addr(char *addr)
-{
-        unsigned int serial;
-
-        if (system_serial_low == 0 && system_serial_high == 0)
-                return -ENODEV;
-
-        serial = system_serial_low | system_serial_high;
-
-        addr[0] = 0;
-        addr[1] = 0;
-        addr[2] = 0xa4;
-        addr[3] = 0x10 + (serial >> 24);
-        addr[4] = serial >> 16;
-        addr[5] = (serial >> 8) + dev_num;
-
-        dev_num++;
-
-        return 0;
-}
-*/
-
 static int
 rtl8125_get_mac_address(struct net_device *dev)
 {
@@ -10968,13 +12061,12 @@ rtl8125_get_mac_address(struct net_devic
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7) {
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8) {
                 *(u32*)&mac_addr[0] = RTL_R32(tp, BACKUP_ADDR0_8125);
                 *(u16*)&mac_addr[4] = RTL_R16(tp, BACKUP_ADDR1_8125);
         }
 
-        /* ethernet_addr(mac_addr); */
-
         if (!is_valid_ether_addr(mac_addr)) {
                 netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
                           mac_addr);
@@ -11870,6 +12962,7 @@ rtl8125_phy_power_up(struct net_device *
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_wait_phy_ups_resume(dev, 3);
                 break;
         };
@@ -11983,11 +13076,11 @@ rtl8125_init_board(struct pci_dev *pdev,
 
         if ((sizeof(dma_addr_t) > 4) &&
             use_dac &&
-            !pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) &&
-            !pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {
+            !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
+            !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
                 dev->features |= NETIF_F_HIGHDMA;
         } else {
-                rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+                rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
                 if (rc < 0) {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
                         if (netif_msg_probe(tp))
@@ -12072,6 +13165,9 @@ rtl8125_esd_checker(struct rtl8125_priva
         u32 pci_sn_l;
         u32 pci_sn_h;
 
+        if (unlikely(tp->rtk_enable_diag))
+                goto exit;
+
         tp->esd_flag = 0;
 
         pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
@@ -12189,8 +13285,8 @@ rtl8125_esd_checker(struct rtl8125_priva
 
         if (tp->esd_flag != 0) {
                 printk(KERN_ERR "%s: esd_flag = 0x%04x\n.\n", dev->name, tp->esd_flag);
-                netif_tx_stop_all_queues(dev);
                 netif_carrier_off(dev);
+                netif_tx_disable(dev);
                 rtl8125_hw_reset(dev);
                 rtl8125_tx_clear(tp);
                 rtl8125_rx_clear(tp);
@@ -12312,6 +13408,7 @@ static int rtl8125_try_msi(struct rtl812
         case CFG_METHOD_4:
         case CFG_METHOD_5:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 tp->max_irq_nvecs = R8125_MAX_MSIX_VEC_8125B;
                 tp->min_irq_nvecs = R8125_MIN_MSIX_VEC_8125B;
                 break;
@@ -12366,11 +13463,57 @@ static int rtl8125_get_irq(struct pci_de
 #endif
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+static void
+rtl8125_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters = tp->tally_vaddr;
+        dma_addr_t paddr = tp->tally_paddr;
+
+        if (!counters)
+                return;
+
+        netdev_stats_to_stats64(stats, &dev->stats);
+        dev_fetch_sw_netstats(stats, dev->tstats);
+
+        /*
+         * Fetch additional counter values missing in stats collected by driver
+         * from tally counters.
+         */
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        stats->tx_errors = le64_to_cpu(counters->tx_errors);
+        stats->collisions = le32_to_cpu(counters->tx_multi_collision);
+        stats->tx_aborted_errors = le16_to_cpu(counters->tx_aborted) ;
+        stats->rx_missed_errors = le16_to_cpu(counters->rx_missed);
+}
+#else
+/**
+ *  rtl8125_get_stats - Get rtl8125 read/write statistics
+ *  @dev: The Ethernet Device to get statistics for
+ *
+ *  Get TX/RX statistics for rtl8125
+ */
+static struct
+net_device_stats *rtl8125_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        struct rtl8125_private *tp = netdev_priv(dev);
+#endif
+        return &RTLDEV->stats;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
 static const struct net_device_ops rtl8125_netdev_ops = {
         .ndo_open       = rtl8125_open,
         .ndo_stop       = rtl8125_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        .ndo_get_stats64    = rtl8125_get_stats64,
+#else
         .ndo_get_stats      = rtl8125_get_stats,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
         .ndo_start_xmit     = rtl8125_start_xmit,
         .ndo_tx_timeout     = rtl8125_tx_timeout,
         .ndo_change_mtu     = rtl8125_change_mtu,
@@ -12578,7 +13721,7 @@ static int rtl8125_poll_msix_rx(napi_ptr
         return RTL_NAPI_RETURN_VALUE;
 }
 
-static void rtl8125_enable_napi(struct rtl8125_private *tp)
+void rtl8125_enable_napi(struct rtl8125_private *tp)
 {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
         int i;
@@ -12688,6 +13831,13 @@ rtl8125_init_one(struct pci_dev *pdev,
         tp->phy_reset_pending = rtl8125_xmii_reset_pending;
         tp->link_ok = rtl8125_xmii_link_ok;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+        dev->tstats = devm_netdev_alloc_pcpu_stats(&pdev->dev,
+                        struct pcpu_sw_netstats);
+        if (!dev->tstats)
+                goto err_out_1;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+
         rc = rtl8125_try_msi(tp);
         if (rc < 0) {
                 dev_err(&pdev->dev, "Can't allocate interrupt\n");
@@ -12730,12 +13880,11 @@ rtl8125_init_one(struct pci_dev *pdev,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
                 tp->cp_cmd |= RxChkSum;
 #else
-                //dev->features |= NETIF_F_RXCSUM;
+                dev->features |= NETIF_F_RXCSUM;
                 dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
                                    NETIF_F_RXCSUM | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
                 dev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
                                      NETIF_F_HIGHDMA;
-                dev->features |= dev->hw_features;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
                 dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
 #endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
@@ -12744,6 +13893,10 @@ rtl8125_init_one(struct pci_dev *pdev,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
                 dev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
                 dev->features |=  NETIF_F_IPV6_CSUM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
+                netif_set_tso_max_size(dev, LSO_64K);
+                netif_set_tso_max_segs(dev, NIC_MAX_PHYS_BUF_COUNT_LSO2);
+#else //LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
                 netif_set_gso_max_size(dev, LSO_64K);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
                 dev->gso_max_segs = NIC_MAX_PHYS_BUF_COUNT_LSO2;
@@ -12751,6 +13904,7 @@ rtl8125_init_one(struct pci_dev *pdev,
                 dev->gso_min_segs = NIC_MIN_PHYS_BUF_COUNT;
 #endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
 #endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,19,0)
 
 #endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
 #endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
@@ -12857,7 +14011,7 @@ rtl8125_remove_one(struct pci_dev *pdev)
 #ifdef  CONFIG_R8125_NAPI
         rtl8125_del_napi(tp);
 #endif
-        if (tp->DASH)
+        if (HW_DASH_SUPPORT_DASH(tp))
                 rtl8125_driver_stop(tp);
 
         unregister_netdev(dev);
@@ -12879,13 +14033,31 @@ rtl8125_remove_one(struct pci_dev *pdev)
         pci_set_drvdata(pdev, NULL);
 }
 
+#ifdef ENABLE_PAGE_REUSE
+static inline unsigned int rtl8125_rx_page_order(unsigned rx_buf_sz, unsigned page_size)
+{
+        unsigned truesize = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +
+                            SKB_DATA_ALIGN(rx_buf_sz + R8125_RX_ALIGN);
+
+        return get_order(truesize * 2);
+}
+#endif //ENABLE_PAGE_REUSE
+
 static void
 rtl8125_set_rxbufsize(struct rtl8125_private *tp,
                       struct net_device *dev)
 {
         unsigned int mtu = dev->mtu;
 
-        tp->rx_buf_sz = (mtu > ETH_DATA_LEN) ? mtu + ETH_HLEN + 8 + 1 : RX_BUF_SIZE;
+        tp->rms = (mtu > ETH_DATA_LEN) ? mtu + ETH_HLEN + 8 + 1 : RX_BUF_SIZE;
+        tp->rx_buf_sz = tp->rms;
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+        tp->rx_buf_sz =  SKB_DATA_ALIGN(RX_BUF_SIZE);
+#endif //ENABLE_RX_PACKET_FRAGMENT
+#ifdef ENABLE_PAGE_REUSE
+        tp->rx_buf_page_order = rtl8125_rx_page_order(tp->rx_buf_sz, PAGE_SIZE);
+        tp->rx_buf_page_size = rtl8125_rx_page_size(tp->rx_buf_page_order);
+#endif //ENABLE_PAGE_REUSE
 }
 
 static void rtl8125_free_irq(struct rtl8125_private *tp)
@@ -12982,8 +14154,9 @@ static int rtl8125_alloc_tx_desc(struct
 
         for (i = 0; i < tp->num_tx_rings; i++) {
                 ring = &tp->tx_ring[i];
+                ring->TxDescAllocSize = (ring->num_tx_desc + 1) * sizeof(struct TxDesc);
                 ring->TxDescArray = dma_alloc_coherent(&pdev->dev,
-                                                       (ring->num_tx_desc * sizeof(struct TxDesc)),
+                                                       ring->TxDescAllocSize,
                                                        &ring->TxPhyAddr,
                                                        GFP_KERNEL);
 
@@ -13002,8 +14175,9 @@ static int rtl8125_alloc_rx_desc(struct
 
         for (i = 0; i < tp->num_rx_rings; i++) {
                 ring = &tp->rx_ring[i];
+                ring->RxDescAllocSize = (ring->num_rx_desc + 1) * tp->RxDescLength;
                 ring->RxDescArray = dma_alloc_coherent(&pdev->dev,
-                                                       (ring->num_rx_desc * tp->RxDescLength),
+                                                       ring->RxDescAllocSize,
                                                        &ring->RxPhyAddr,
                                                        GFP_KERNEL);
 
@@ -13042,7 +14216,7 @@ static void rtl8125_free_tx_desc(struct
                 ring = &tp->tx_ring[i];
                 if (ring->TxDescArray) {
                         dma_free_coherent(&pdev->dev,
-                                          (ring->num_tx_desc * sizeof(struct TxDesc)),
+                                          ring->TxDescAllocSize,
                                           ring->TxDescArray,
                                           ring->TxPhyAddr);
                         ring->TxDescArray = NULL;
@@ -13060,7 +14234,7 @@ static void rtl8125_free_rx_desc(struct
                 ring = &tp->rx_ring[i];
                 if (ring->RxDescArray) {
                         dma_free_coherent(&pdev->dev,
-                                          (ring->num_rx_desc * tp->RxDescLength),
+                                          ring->RxDescAllocSize,
                                           ring->RxDescArray,
                                           ring->RxPhyAddr);
                         ring->RxDescArray = NULL;
@@ -13334,7 +14508,6 @@ rtl8125_hw_config(struct net_device *dev
         struct rtl8125_private *tp = netdev_priv(dev);
         struct pci_dev *pdev = tp->pci_dev;
         u16 mac_ocp_data;
-        int i;
 
         RTL_W32(tp, RxConfig, (RX_DMA_BURST << RxCfgDMAShift));
 
@@ -13348,6 +14521,7 @@ rtl8125_hw_config(struct net_device *dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
                 RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
                 RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
@@ -13366,19 +14540,6 @@ rtl8125_hw_config(struct net_device *dev
                 break;
         }
 
-        switch (tp->mcfg) {
-        case CFG_METHOD_2:
-        case CFG_METHOD_3:
-        case CFG_METHOD_4:
-        case CFG_METHOD_5:
-        case CFG_METHOD_6:
-        case CFG_METHOD_7:
-                //IntMITI_0-IntMITI_31
-                for (i=0xA00; i<0xB00; i+=4)
-                        RTL_W32(tp, i, 0x00000000);
-                break;
-        }
-
         //keep magic packet only
         switch (tp->mcfg) {
         case CFG_METHOD_2:
@@ -13387,6 +14548,7 @@ rtl8125_hw_config(struct net_device *dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xC0B6);
                 mac_ocp_data &= BIT_0;
                 rtl8125_mac_ocp_write(tp, 0xC0B6, mac_ocp_data);
@@ -13406,12 +14568,18 @@ rtl8125_hw_config(struct net_device *dev
         if (tp->EnableTxNoClose)
                 RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_6));
 
+        if (enable_double_vlan)
+                rtl8125_enable_double_vlan(tp);
+        else
+                rtl8125_disable_double_vlan(tp);
+
         if (tp->mcfg == CFG_METHOD_2 ||
             tp->mcfg == CFG_METHOD_3 ||
             tp->mcfg == CFG_METHOD_4 ||
             tp->mcfg == CFG_METHOD_5 ||
             tp->mcfg == CFG_METHOD_6 ||
-            tp->mcfg == CFG_METHOD_7) {
+            tp->mcfg == CFG_METHOD_7 ||
+            tp->mcfg == CFG_METHOD_8) {
                 set_offset70F(tp, 0x27);
                 set_offset79(tp, 0x50);
 
@@ -13439,6 +14607,8 @@ rtl8125_hw_config(struct net_device *dev
                 if (tp->mcfg == CFG_METHOD_4 || tp->mcfg == CFG_METHOD_5 ||
                     tp->mcfg == CFG_METHOD_7)
                         mac_ocp_data |= ((2 & 0x07) << 8);
+                else if (tp->mcfg == CFG_METHOD_8)
+                        mac_ocp_data |= ((4 & 0x07) << 8);
                 else
                         mac_ocp_data |= ((3 & 0x07) << 8);
                 rtl8125_mac_ocp_write(tp, 0xE614, mac_ocp_data);
@@ -13448,7 +14618,7 @@ rtl8125_hw_config(struct net_device *dev
                 mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE63E);
                 mac_ocp_data &= ~(BIT_5 | BIT_4);
                 if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3 ||
-                    tp->mcfg == CFG_METHOD_6)
+                    tp->mcfg == CFG_METHOD_6 || tp->mcfg == CFG_METHOD_8)
                         mac_ocp_data |= ((0x02 & 0x03) << 4);
                 rtl8125_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
 
@@ -13561,6 +14731,7 @@ rtl8125_hw_config(struct net_device *dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 rtl8125_mac_ocp_write(tp, 0xE098, 0xC302);
                 break;
         }
@@ -13572,8 +14743,11 @@ rtl8125_hw_config(struct net_device *dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
+                rtl8125_disable_pci_offset_99(tp);
                 if (aspm) {
-                        rtl8125_init_pci_offset_99(tp);
+                        if (tp->org_pci_offset_99 & (BIT_2 | BIT_5 | BIT_6))
+                                rtl8125_init_pci_offset_99(tp);
                 }
                 break;
         }
@@ -13584,8 +14758,11 @@ rtl8125_hw_config(struct net_device *dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
+                rtl8125_disable_pci_offset_180(tp);
                 if (aspm) {
-                        rtl8125_init_pci_offset_180(tp);
+                        if (tp->org_pci_offset_180 & (BIT_0|BIT_1))
+                                rtl8125_init_pci_offset_180(tp);
                 }
                 break;
         }
@@ -13617,7 +14794,7 @@ rtl8125_hw_config(struct net_device *dev
         break;
         }
 
-        RTL_W16(tp, RxMaxSize, tp->rx_buf_sz);
+        RTL_W16(tp, RxMaxSize, tp->rms);
 
         rtl8125_disable_rxdvgate(dev);
 
@@ -13659,6 +14836,7 @@ rtl8125_hw_config(struct net_device *dev
         case CFG_METHOD_5:
         case CFG_METHOD_6:
         case CFG_METHOD_7:
+        case CFG_METHOD_8:
                 if (aspm) {
                         RTL_W8(tp, Config5, RTL_R8(tp, Config5) | BIT_0);
                         RTL_W8(tp, Config2, RTL_R8(tp, Config2) | BIT_7);
@@ -13679,6 +14857,10 @@ rtl8125_hw_start(struct net_device *dev)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
 
+#ifdef ENABLE_LIB_SUPPORT
+        rtl8125_init_lib_ring(tp);
+#endif
+
         RTL_W8(tp, ChipCmd, CmdTxEnb | CmdRxEnb);
 
         rtl8125_enable_hw_interrupt(tp);
@@ -13718,8 +14900,8 @@ rtl8125_change_mtu(struct net_device *de
         rtl8125_enable_napi(tp);
 #endif//CONFIG_R8125_NAPI
 
-        //netif_tx_stop_all_queues(dev);
         //netif_carrier_off(dev);
+        //netif_tx_disable(dev);
         rtl8125_hw_config(dev);
         rtl8125_enable_hw_linkchg_interrupt(tp);
 
@@ -13736,22 +14918,6 @@ err_out:
         return ret;
 }
 
-static void
-rtl8125_free_rx_skb(struct rtl8125_private *tp,
-                    struct rtl8125_rx_ring *ring,
-                    struct sk_buff **sk_buff,
-                    struct RxDesc *desc,
-                    const u32 cur_rx)
-{
-        struct pci_dev *pdev = tp->pci_dev;
-
-        dma_unmap_single(&pdev->dev, ring->RxDescPhyAddr[cur_rx], tp->rx_buf_sz,
-                         DMA_FROM_DEVICE);
-        dev_kfree_skb(*sk_buff);
-        *sk_buff = NULL;
-        rtl8125_make_unusable_by_asic(tp, desc);
-}
-
 static inline void
 rtl8125_mark_to_asic_v3(struct RxDescV3 *descv3,
                         u32 rx_buf_sz)
@@ -13792,6 +14958,125 @@ rtl8125_map_to_asic(struct rtl8125_priva
         rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
 }
 
+#ifdef ENABLE_PAGE_REUSE
+
+static int
+rtl8125_alloc_rx_page(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring,
+                      struct rtl8125_rx_buffer *rxb)
+{
+        struct page *page;
+        dma_addr_t dma;
+        unsigned int order = tp->rx_buf_page_order;
+
+        //get free page
+        page = dev_alloc_pages(order);
+
+        if (unlikely(!page))
+                return -ENOMEM;
+
+        dma = dma_map_page_attrs(&tp->pci_dev->dev, page, 0,
+                                 tp->rx_buf_page_size,
+                                 DMA_FROM_DEVICE,
+                                 (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+
+        if (unlikely(dma_mapping_error(&tp->pci_dev->dev, dma))) {
+                __free_pages(page, order);
+                return -ENOMEM;
+        }
+
+        rxb->page = page;
+        rxb->data = page_address(page);
+        rxb->page_offset = ring->rx_offset;
+        rxb->dma = dma;
+
+        //after page alloc, page refcount already = 1
+
+        return 0;
+}
+
+static void
+rtl8125_free_rx_page(struct rtl8125_private *tp, struct rtl8125_rx_buffer *rxb)
+{
+        if (!rxb->page)
+                return;
+
+        dma_unmap_page_attrs(&tp->pci_dev->dev, rxb->dma,
+                             tp->rx_buf_page_size,
+                             DMA_FROM_DEVICE,
+                             (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+        __free_pages(rxb->page, tp->rx_buf_page_order);
+        rxb->page = NULL;
+}
+
+static void
+_rtl8125_rx_clear(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring)
+{
+        int i;
+        struct rtl8125_rx_buffer *rxb;
+
+        for (i = 0; i < ring->num_rx_desc; i++) {
+                rxb = &ring->rx_buffer[i];
+                if (rxb->skb) {
+                        dev_kfree_skb(rxb->skb);
+                        rxb->skb = NULL;
+                }
+                rtl8125_free_rx_page(tp, rxb);
+        }
+}
+
+static u32
+rtl8125_rx_fill(struct rtl8125_private *tp,
+                struct rtl8125_rx_ring *ring,
+                struct net_device *dev,
+                u32 start,
+                u32 end,
+                u8 in_intr)
+{
+        u32 cur;
+        struct rtl8125_rx_buffer *rxb;
+
+        for (cur = start; end - cur > 0; cur++) {
+                int ret, i = cur % ring->num_rx_desc;
+
+                rxb = &ring->rx_buffer[i];
+                if (rxb->page)
+                        continue;
+
+                ret = rtl8125_alloc_rx_page(tp, ring, rxb);
+                if (ret)
+                        break;
+
+                dma_sync_single_range_for_device(tp_to_dev(tp),
+                                                 rxb->dma,
+                                                 rxb->page_offset,
+                                                 tp->rx_buf_sz,
+                                                 DMA_FROM_DEVICE);
+
+                rtl8125_map_to_asic(tp, ring, ring->RxDescArray + i,
+                                    rxb->dma + rxb->page_offset,
+                                    tp->rx_buf_sz, i);
+        }
+        return cur - start;
+}
+
+#else //ENABLE_PAGE_REUSE
+
+static void
+rtl8125_free_rx_skb(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    struct RxDesc *desc,
+                    const u32 cur_rx)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+
+        dma_unmap_single(&pdev->dev, ring->RxDescPhyAddr[cur_rx], tp->rx_buf_sz,
+                         DMA_FROM_DEVICE);
+        dev_kfree_skb(*sk_buff);
+        *sk_buff = NULL;
+        rtl8125_make_unusable_by_asic(tp, desc);
+}
+
 static int
 rtl8125_alloc_rx_skb(struct rtl8125_private *tp,
                      struct rtl8125_rx_ring *ring,
@@ -13806,14 +15091,14 @@ rtl8125_alloc_rx_skb(struct rtl8125_priv
         int ret = 0;
 
         if (in_intr)
-                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, rx_buf_sz + RTK_RX_ALIGN);
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, rx_buf_sz + R8125_RX_ALIGN);
         else
-                skb = dev_alloc_skb(rx_buf_sz + RTK_RX_ALIGN);
+                skb = dev_alloc_skb(rx_buf_sz + R8125_RX_ALIGN);
 
         if (unlikely(!skb))
                 goto err_out;
 
-        skb_reserve(skb, RTK_RX_ALIGN);
+        skb_reserve(skb, R8125_RX_ALIGN);
 
         mapping = dma_map_single(tp_to_dev(tp), skb->data, rx_buf_sz,
                                  DMA_FROM_DEVICE);
@@ -13853,15 +15138,6 @@ _rtl8125_rx_clear(struct rtl8125_private
         }
 }
 
-void
-rtl8125_rx_clear(struct rtl8125_private *tp)
-{
-        int i;
-
-        for (i = 0; i < tp->num_rx_rings; i++)
-                _rtl8125_rx_clear(tp, &tp->rx_ring[i]);
-}
-
 static u32
 rtl8125_rx_fill(struct rtl8125_private *tp,
                 struct rtl8125_rx_ring *ring,
@@ -13892,6 +15168,20 @@ rtl8125_rx_fill(struct rtl8125_private *
         return cur - start;
 }
 
+#endif //ENABLE_PAGE_REUSE
+
+void
+rtl8125_rx_clear(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+
+                _rtl8125_rx_clear(tp, ring);
+        }
+}
+
 static inline void
 rtl8125_mark_as_last_descriptor_8125(struct RxDescV3 *descv3)
 {
@@ -13933,7 +15223,7 @@ rtl8125_tx_desc_init(struct rtl8125_priv
 
         for (i = 0; i < tp->num_tx_rings; i++) {
                 struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
-                memset(ring->TxDescArray, 0x0, (ring->num_tx_desc * sizeof(struct TxDesc)));
+                memset(ring->TxDescArray, 0x0, ring->TxDescAllocSize);
 
                 ring->TxDescArray[ring->num_tx_desc - 1].opts1 = cpu_to_le32(RingEnd);
         }
@@ -13946,8 +15236,7 @@ rtl8125_rx_desc_init(struct rtl8125_priv
 
         for (i = 0; i < tp->num_rx_rings; i++) {
                 struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
-                memset(ring->RxDescArray, 0x0,
-                       (ring->num_rx_desc * tp->RxDescLength));
+                memset(ring->RxDescArray, 0x0, ring->RxDescAllocSize);
         }
 }
 
@@ -13969,8 +15258,11 @@ rtl8125_init_ring(struct net_device *dev
 
         for (i = 0; i < tp->num_rx_rings; i++) {
                 struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
-
+#ifdef ENABLE_PAGE_REUSE
+                ring->rx_offset = R8125_RX_ALIGN;
+#else
                 memset(ring->Rx_skbuff, 0x0, sizeof(ring->Rx_skbuff));
+#endif //ENABLE_PAGE_REUSE
                 if (rtl8125_rx_fill(tp, ring, dev, 0, ring->num_rx_desc, 0) != ring->num_rx_desc)
                         goto err_out;
 
@@ -14104,7 +15396,7 @@ static void rtl8125_cancel_schedule_esd_
 static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp)
 {
         set_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
-        schedule_delayed_work(&tp->linkchg_task, RTL8125_ESD_TIMEOUT);
+        schedule_delayed_work(&tp->linkchg_task, 4);
 }
 
 static void rtl8125_cancel_schedule_linkchg_work(struct rtl8125_private *tp)
@@ -14149,7 +15441,7 @@ rtl8125_wait_for_irq_complete(struct rtl
         }
 }
 
-static void
+void
 _rtl8125_wait_for_quiescence(struct net_device *dev)
 {
         struct rtl8125_private *tp = netdev_priv(dev);
@@ -14224,8 +15516,8 @@ static void rtl8125_reset_task(struct wo
 #endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
         }
 
-        netif_tx_stop_all_queues(dev);
         netif_carrier_off(dev);
+        netif_tx_disable(dev);
         rtl8125_hw_reset(dev);
 
         rtl8125_tx_clear(tp);
@@ -14600,13 +15892,12 @@ rtl8125_tso_csum(struct sk_buff *skb,
 
                 /* TCP Segmentation Offload (or TCP Large Send) */
                 if (mss) {
-                        u32 transport_offset = (u32)skb_transport_offset(skb);
-                        assert((transport_offset%2) == 0);
+                        assert((skb_transport_offset(skb)%2) == 0);
                         switch (get_protocol(skb)) {
                         case __constant_htons(ETH_P_IP):
-                                if (transport_offset <= GTTCPHO_MAX) {
+                                if (skb_transport_offset(skb) <= GTTCPHO_MAX) {
                                         opts[0] |= GiantSendv4;
-                                        opts[0] |= transport_offset << GTTCPHO_SHIFT;
+                                        opts[0] |= skb_transport_offset(skb) << GTTCPHO_SHIFT;
                                         opts[1] |= min(mss, MSS_MAX) << 18;
                                         large_send = 1;
                                 }
@@ -14616,9 +15907,9 @@ rtl8125_tso_csum(struct sk_buff *skb,
                                 if (msdn_giant_send_check(skb))
                                         return false;
 #endif
-                                if (transport_offset <= GTTCPHO_MAX) {
+                                if (skb_transport_offset(skb) <= GTTCPHO_MAX) {
                                         opts[0] |= GiantSendv6;
-                                        opts[0] |= transport_offset << GTTCPHO_SHIFT;
+                                        opts[0] |= skb_transport_offset(skb) << GTTCPHO_SHIFT;
                                         opts[1] |= min(mss, MSS_MAX) << 18;
                                         large_send = 1;
                                 }
@@ -14661,11 +15952,10 @@ rtl8125_tso_csum(struct sk_buff *skb,
                         break;
                 case  __constant_htons(ETH_P_IPV6):
                         if (dev->features & NETIF_F_IPV6_CSUM) {
-                                u32 transport_offset = (u32)skb_transport_offset(skb);
-                                if (transport_offset > 0 && transport_offset <= TCPHO_MAX) {
+                                if (skb_transport_offset(skb) > 0 && skb_transport_offset(skb) <= TCPHO_MAX) {
                                         ip_protocol = ipv6_hdr(skb)->nexthdr;
                                         csum_cmd = tp->tx_ipv6_csum_cmd;
-                                        csum_cmd |= transport_offset << TCPHO_SHIFT;
+                                        csum_cmd |= skb_transport_offset(skb) << TCPHO_SHIFT;
                                 }
                         }
                         break;
@@ -14738,6 +16028,12 @@ static bool rtl8125_tx_slots_avail(struc
         return slots_avail > MAX_SKB_FRAGS;
 }
 
+static inline u32
+rtl8125_fast_mod_mask(const u32 input, const u32 mask)
+{
+        return input > mask ? input & mask : input;
+}
+
 static netdev_tx_t
 rtl8125_start_xmit(struct sk_buff *skb,
                    struct net_device *dev)
@@ -14851,9 +16147,12 @@ rtl8125_start_xmit(struct sk_buff *skb,
                 netif_stop_subqueue(dev, queue_mapping);
         }
 
-        if (EnableTxNoClose)
-                RTL_W16(tp, ring->sw_tail_ptr_reg, ring->cur_tx % MAX_TX_NO_CLOSE_DESC_PTR_V2);
-        else
+        if (EnableTxNoClose) {
+                if (tp->HwSuppTxNoCloseVer == 4)
+                        RTL_W32(tp, ring->sw_tail_ptr_reg, ring->cur_tx);
+                else
+                        RTL_W16(tp, ring->sw_tail_ptr_reg, ring->cur_tx);
+        } else
                 RTL_W16(tp, TPPOLL_8125, BIT(ring->index));    /* set polling bit */
 
         if (unlikely(stop_queue)) {
@@ -14885,10 +16184,22 @@ err_stop:
         goto out;
 }
 
-static inline u32
-rtl8125_fast_mod(const u32 input, const u32 ceil)
+static u32
+rtl8125_get_hw_clo_ptr(struct rtl8125_tx_ring *ring)
 {
-        return input >= ceil ? input % ceil : input;
+        struct rtl8125_private *tp = ring->priv;
+
+        switch (tp->HwSuppTxNoCloseVer) {
+        case 3:
+                return RTL_R16(tp, ring->hw_clo_ptr_reg);
+        case 4:
+                return RTL_R32(tp, ring->hw_clo_ptr_reg);
+        default:
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                WARN_ON(1);
+#endif
+                return 0;
+        }
 }
 
 static int
@@ -14905,10 +16216,10 @@ rtl8125_tx_interrupt(struct rtl8125_tx_r
         tx_left = READ_ONCE(ring->cur_tx) - dirty_tx;
         if (EnableTxNoClose) {
                 unsigned int tx_desc_closed;
-                u32 NextHwDesCloPtr = RTL_R16(tp, ring->hw_clo_ptr_reg);
+                u32 NextHwDesCloPtr = rtl8125_get_hw_clo_ptr(ring);
                 ring->NextHwDesCloPtr = NextHwDesCloPtr;
                 smp_rmb();
-                tx_desc_closed = rtl8125_fast_mod(NextHwDesCloPtr - ring->BeginHwDesCloPtr, MAX_TX_NO_CLOSE_DESC_PTR_V2);
+                tx_desc_closed = rtl8125_fast_mod_mask(NextHwDesCloPtr - ring->BeginHwDesCloPtr, tp->MaxTxDescPtrMask);
                 if(tx_left > tx_desc_closed) tx_left = tx_desc_closed;
                 ring->BeginHwDesCloPtr = NextHwDesCloPtr;
         }
@@ -14980,6 +16291,15 @@ rtl8125_fragmented_frame(struct rtl8125_
 }
 
 static inline int
+rtl8125_is_non_eop(struct rtl8125_private *tp, u32 status)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                return !(status & LastFrag_V3);
+        else
+                return !(status & LastFrag);
+}
+
+static inline int
 rtl8125_rx_desc_type(u32 status)
 {
         return ((status >> 26) & 0x0F);
@@ -14990,43 +16310,35 @@ rtl8125_rx_v3_csum(struct rtl8125_privat
                    struct sk_buff *skb,
                    struct RxDescV3 *descv3)
 {
-        //u32 opts1 = le32_to_cpu(descv3->RxDescNormalDDWord4.opts1);
         u32 opts2 = le32_to_cpu(descv3->RxDescNormalDDWord4.opts2);
 
         /* rx csum offload for RTL8125 */
-        if (((opts2 & RxV4F_v3) && !(opts2 & RxIPF_v3)) || (opts2 & RxV6F_v3)) {
-                if (((opts2 & RxTCPT_v3) && !(opts2 & RxTCPF_v3)) ||
-                    ((opts2 & RxUDPT_v3) && !(opts2 & RxUDPF_v3)))
-                        skb->ip_summed = CHECKSUM_UNNECESSARY;
-                else
-                        skb->ip_summed = CHECKSUM_NONE;
-        } else
-                skb->ip_summed = CHECKSUM_NONE;
+        if (((opts2 & RxTCPT_v3) && !(opts2 & RxTCPF_v3)) ||
+            ((opts2 & RxUDPT_v3) && !(opts2 & RxUDPF_v3)))
+                skb->ip_summed = CHECKSUM_UNNECESSARY;
+        else
+                skb_checksum_none_assert(skb);
 }
 
 static inline void
 rtl8125_rx_csum(struct rtl8125_private *tp,
                 struct sk_buff *skb,
-                struct RxDesc *desc)
+                struct RxDesc *desc,
+                u32 opts1)
 {
         if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
                 rtl8125_rx_v3_csum(tp, skb, (struct RxDescV3 *)desc);
         else {
-                u32 opts1 = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc));
-                u32 opts2 = le32_to_cpu(rtl8125_rx_desc_opts2(tp, desc));
-
                 /* rx csum offload for RTL8125 */
-                if (((opts2 & RxV4F) && !(opts1 & RxIPF)) || (opts2 & RxV6F)) {
-                        if (((opts1 & RxTCPT) && !(opts1 & RxTCPF)) ||
-                            ((opts1 & RxUDPT) && !(opts1 & RxUDPF)))
-                                skb->ip_summed = CHECKSUM_UNNECESSARY;
-                        else
-                                skb->ip_summed = CHECKSUM_NONE;
-                } else
-                        skb->ip_summed = CHECKSUM_NONE;
+                if (((opts1 & RxTCPT) && !(opts1 & RxTCPF)) ||
+                    ((opts1 & RxUDPT) && !(opts1 & RxUDPF)))
+                        skb->ip_summed = CHECKSUM_UNNECESSARY;
+                else
+                        skb_checksum_none_assert(skb);
         }
 }
 
+/*
 static inline int
 rtl8125_try_rx_copy(struct rtl8125_private *tp,
                     struct rtl8125_rx_ring *ring,
@@ -15037,26 +16349,26 @@ rtl8125_try_rx_copy(struct rtl8125_priva
 {
         int ret = -1;
 
-        if (pkt_size < rx_copybreak) {
-                struct sk_buff *skb;
+        struct sk_buff *skb;
 
-                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, pkt_size + RTK_RX_ALIGN);
-                if (skb) {
-                        u8 *data;
+        skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, pkt_size + R8125_RX_ALIGN);
+        if (skb) {
+                u8 *data;
 
-                        data = sk_buff[0]->data;
-                        skb_reserve(skb, RTK_RX_ALIGN);
+                data = sk_buff[0]->data;
+                skb_reserve(skb, R8125_RX_ALIGN);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
-                        prefetch(data - RTK_RX_ALIGN);
+                prefetch(data - R8125_RX_ALIGN);
 #endif
-                        eth_copy_and_sum(skb, data, pkt_size, 0);
-                        *sk_buff = skb;
-                        rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
-                        ret = 0;
-                }
+                eth_copy_and_sum(skb, data, pkt_size, 0);
+                *sk_buff = skb;
+                rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
+                ret = 0;
         }
+
         return ret;
 }
+*/
 
 static inline void
 rtl8125_rx_skb(struct rtl8125_private *tp,
@@ -15104,6 +16416,95 @@ rtl8125_check_rx_desc_error(struct net_d
         return ret;
 }
 
+#ifdef ENABLE_PAGE_REUSE
+
+static inline bool
+rtl8125_reuse_rx_ok(struct page *page)
+{
+        /* avoid re-using remote pages */
+        if (!dev_page_is_reusable(page)) {
+                //printk(KERN_INFO "r8125 page pfmemalloc, can't reuse!\n");
+                return false;
+        }
+        /* if we are only owner of page we can reuse it */
+        if (unlikely(page_ref_count(page) != 1)) {
+                //printk(KERN_INFO "r8125 page refcnt %d, can't reuse!\n", page_ref_count(page));
+                return false;
+        }
+
+        return true;
+}
+
+static void
+rtl8125_reuse_rx_buffer(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring, u32 cur_rx, struct rtl8125_rx_buffer *rxb)
+{
+        struct page *page = rxb->page;
+
+        u32 dirty_rx = ring->dirty_rx;
+        u32 entry = dirty_rx % ring->num_rx_desc;
+        struct rtl8125_rx_buffer *nrxb = &ring->rx_buffer[entry];
+
+        u32 noffset;
+
+        //the page gonna be shared by us and kernel, keep page ref = 2
+        page_ref_inc(page);
+
+        //flip the buffer in page to use next
+        noffset = rxb->page_offset ^ (tp->rx_buf_page_size / 2); //one page, two buffer, ping-pong
+
+        nrxb->dma = rxb->dma;
+        nrxb->page_offset = noffset;
+        nrxb->data = rxb->data;
+
+        if (cur_rx != dirty_rx) {
+                //move the buffer to other slot
+                nrxb->page = page;
+                rxb->page = NULL;
+        }
+}
+
+static void rtl8125_put_rx_buffer(struct rtl8125_private *tp,
+                                  struct rtl8125_rx_ring *ring,
+                                  u32 cur_rx,
+                                  struct rtl8125_rx_buffer *rxb)
+{
+        struct rtl8125_rx_buffer *nrxb;
+        struct page *page = rxb->page;
+        u32 entry;
+
+        entry = ring->dirty_rx % ring->num_rx_desc;
+        nrxb = &ring->rx_buffer[entry];
+        if (likely(rtl8125_reuse_rx_ok(page))) {
+                /* hand second half of page back to the ring */
+                rtl8125_reuse_rx_buffer(tp, ring, cur_rx, rxb);
+        } else {
+                tp->page_reuse_fail_cnt++;
+
+                dma_unmap_page_attrs(&tp->pci_dev->dev, rxb->dma,
+                                     tp->rx_buf_page_size,
+                                     DMA_FROM_DEVICE,
+                                     (DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING));
+                //the page ref is kept 1, uniquely owned by kernel now
+                rxb->page = NULL;
+
+                return;
+        }
+
+        dma_sync_single_range_for_device(tp_to_dev(tp),
+                                         nrxb->dma,
+                                         nrxb->page_offset,
+                                         tp->rx_buf_sz,
+                                         DMA_FROM_DEVICE);
+
+        rtl8125_map_to_asic(tp, ring, ring->RxDescArray + entry,
+                            nrxb->dma + nrxb->page_offset,
+                            tp->rx_buf_sz, entry);
+
+        ring->dirty_rx++;
+}
+
+#endif //ENABLE_PAGE_REUSE
+
 static int
 rtl8125_rx_interrupt(struct net_device *dev,
                      struct rtl8125_private *tp,
@@ -15114,10 +16515,17 @@ rtl8125_rx_interrupt(struct net_device *
         unsigned int delta, count = 0;
         unsigned int entry;
         struct RxDesc *desc;
+        struct sk_buff *skb;
         u32 status;
         u32 rx_quota;
-        u64 rx_buf_phy_addr;
         u32 ring_index = ring->index;
+#ifdef ENABLE_PAGE_REUSE
+        struct rtl8125_rx_buffer *rxb;
+#else //ENABLE_PAGE_REUSE
+        u64 rx_buf_phy_addr;
+#endif //ENABLE_PAGE_REUSE
+        unsigned int total_rx_multicast_packets = 0;
+        unsigned int total_rx_bytes = 0, total_rx_packets = 0;
 
         assert(dev != NULL);
         assert(tp != NULL);
@@ -15127,17 +16535,24 @@ rtl8125_rx_interrupt(struct net_device *
 
         rx_quota = RTL_RX_QUOTA(budget);
         cur_rx = ring->cur_rx;
-        entry = cur_rx % ring->num_rx_desc;
-        desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
         rx_left = ring->num_rx_desc + ring->dirty_rx - cur_rx;
         rx_left = rtl8125_rx_quota(rx_left, (u32)rx_quota);
 
-        for (; rx_left > 0; rx_left--) {
-                rmb();
+        for (; rx_left > 0; rx_left--, cur_rx++) {
+                int pkt_size;
+#ifndef ENABLE_PAGE_REUSE
+                const void *rx_buf;
+#endif //!ENABLE_PAGE_REUSE
+
+                entry = cur_rx % ring->num_rx_desc;
+                desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
                 status = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc));
+
                 if (status & DescOwn)
                         break;
 
+                rmb();
+
                 if (unlikely(rtl8125_check_rx_desc_error(dev, tp, status) < 0)) {
                         if (netif_msg_rx_err(tp)) {
                                 printk(KERN_INFO
@@ -15147,129 +16562,167 @@ rtl8125_rx_interrupt(struct net_device *
 
                         RTLDEV->stats.rx_errors++;
 
-                        if (dev->features & NETIF_F_RXALL)
-                                goto process_pkt;
-
-                        rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
-                } else {
-                        struct sk_buff *skb;
-                        int pkt_size;
-
-process_pkt:
-                        if (likely(!(dev->features & NETIF_F_RXFCS)))
-                                pkt_size = (status & 0x00003fff) - 4;
-                        else
-                                pkt_size = status & 0x00003fff;
-
-                        /*
-                         * The driver does not support incoming fragmented
-                         * frames. They are seen as a symptom of over-mtu
-                         * sized frames.
-                         */
-                        if (unlikely(rtl8125_fragmented_frame(tp, status))) {
-                                RTLDEV->stats.rx_dropped++;
-                                RTLDEV->stats.rx_length_errors++;
-                                rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
-                                continue;
-                        }
+                        if (!(dev->features & NETIF_F_RXALL))
+                                goto release_descriptor;
+                }
+                pkt_size = status & 0x00003fff;
+                if (likely(!(dev->features & NETIF_F_RXFCS)) &&
+                    !rtl8125_is_non_eop(tp, status))
+                        pkt_size -= ETH_FCS_LEN;
 
-                        skb = ring->Rx_skbuff[entry];
+                if (unlikely(pkt_size > tp->rx_buf_sz))
+                        goto drop_packet;
 
-                        if (!skb)
-                                break;
+#if !defined(ENABLE_RX_PACKET_FRAGMENT) || !defined(ENABLE_PAGE_REUSE)
+                /*
+                 * The driver does not support incoming fragmented
+                 * frames. They are seen as a symptom of over-mtu
+                 * sized frames.
+                 */
+                if (unlikely(rtl8125_fragmented_frame(tp, status)))
+                        goto drop_packet;
+#endif //!ENABLE_RX_PACKET_FRAGMENT || !ENABLE_PAGE_REUSE
 
 #ifdef ENABLE_PTP_SUPPORT
-                        if (tp->EnablePtp) {
-                                u8 desc_type;
-
-                                desc_type = rtl8125_rx_desc_type(status);
-                                if (desc_type == RXDESC_TYPE_NEXT && rx_left > 0) {
-                                        u32 status_next;
-                                        struct RxDescV3 *desc_next;
-                                        unsigned int entry_next;
-                                        struct sk_buff *skb_next;
+                if (tp->EnablePtp) {
+                        u8 desc_type;
 
-                                        entry_next = (cur_rx + 1) % ring->num_rx_desc;
-                                        desc_next = (struct RxDescV3 *)rtl8125_get_rxdesc(tp, ring->RxDescArray, entry_next);
+                        desc_type = rtl8125_rx_desc_type(status);
+                        if (desc_type == RXDESC_TYPE_NEXT && rx_left > 0) {
+                                u32 status_next;
+                                struct RxDescV3 *desc_next;
+                                unsigned int entry_next;
+                                struct sk_buff *skb_next;
+
+                                entry_next = (cur_rx + 1) % ring->num_rx_desc;
+                                desc_next = (struct RxDescV3 *)rtl8125_get_rxdesc(tp, ring->RxDescArray, entry_next);
+                                rmb();
+                                status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
+                                if (unlikely(status_next & DescOwn)) {
+                                        udelay(1);
                                         rmb();
                                         status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
                                         if (unlikely(status_next & DescOwn)) {
-                                                udelay(1);
-                                                rmb();
-                                                status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
-                                                if (unlikely(status_next & DescOwn)) {
-                                                        if (netif_msg_rx_err(tp)) {
-                                                                printk(KERN_ERR
-                                                                       "%s: Rx Next Desc ERROR. status = %08x\n",
-                                                                       dev->name, status_next);
-                                                        }
-                                                        break;
+                                                if (netif_msg_rx_err(tp)) {
+                                                        printk(KERN_ERR
+                                                               "%s: Rx Next Desc ERROR. status = %08x\n",
+                                                               dev->name, status_next);
                                                 }
+                                                break;
                                         }
+                                }
 
-                                        cur_rx++;
-                                        rx_left--;
-                                        desc_type = rtl8125_rx_desc_type(status_next);
-                                        if (desc_type == RXDESC_TYPE_PTP)
-                                                rtl8125_rx_ptp_pktstamp(tp, skb, desc_next);
-                                        else
-                                                WARN_ON(1);
-
-                                        rx_buf_phy_addr = ring->RxDescPhyAddr[entry_next];
-                                        dma_unmap_single(tp_to_dev(tp), rx_buf_phy_addr,
-                                                         tp->rx_buf_sz, DMA_FROM_DEVICE);
-                                        skb_next = ring->Rx_skbuff[entry_next];
-                                        dev_kfree_skb_any(skb_next);
-                                        ring->Rx_skbuff[entry_next] = NULL;
-                                } else
-                                        WARN_ON(desc_type != RXDESC_TYPE_NORMAL);
-                        }
-#endif
-                        rx_buf_phy_addr = ring->RxDescPhyAddr[entry];
-                        dma_sync_single_for_cpu(tp_to_dev(tp),
-                                                rx_buf_phy_addr, tp->rx_buf_sz,
-                                                DMA_FROM_DEVICE);
-
-                        if (rtl8125_try_rx_copy(tp, ring, &skb, pkt_size,
-                                                desc, tp->rx_buf_sz)) {
-                                ring->Rx_skbuff[entry] = NULL;
+                                cur_rx++;
+                                rx_left--;
+                                desc_type = rtl8125_rx_desc_type(status_next);
+                                if (desc_type == RXDESC_TYPE_PTP)
+                                        rtl8125_rx_ptp_pktstamp(tp, skb, desc_next);
+                                else
+                                        WARN_ON(1);
+
+                                rx_buf_phy_addr = ring->RxDescPhyAddr[entry_next];
                                 dma_unmap_single(tp_to_dev(tp), rx_buf_phy_addr,
                                                  tp->rx_buf_sz, DMA_FROM_DEVICE);
-                        } else {
-                                dma_sync_single_for_device(tp_to_dev(tp), rx_buf_phy_addr,
-                                                           tp->rx_buf_sz, DMA_FROM_DEVICE);
+                                skb_next = ring->Rx_skbuff[entry_next];
+                                dev_kfree_skb_any(skb_next);
+                                ring->Rx_skbuff[entry_next] = NULL;
+                        } else
+                                WARN_ON(desc_type != RXDESC_TYPE_NORMAL);
+                }
+#endif
+#ifdef ENABLE_PAGE_REUSE
+                rxb = &ring->rx_buffer[entry];
+                skb = rxb->skb;
+                rxb->skb = NULL;
+                if (!skb) {
+                        skb = RTL_BUILD_SKB_INTR(rxb->data + rxb->page_offset - ring->rx_offset, tp->rx_buf_page_size / 2);
+                        if (!skb) {
+                                //netdev_err(tp->dev, "Failed to allocate RX skb!\n");
+                                goto drop_packet;
                         }
 
+                        skb->dev = dev;
+                        skb_reserve(skb, R8125_RX_ALIGN);
+                        skb_put(skb, pkt_size);
+                } else
+                        skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rxb->page,
+                                        rxb->page_offset, pkt_size, tp->rx_buf_page_size / 2);
+
+                //recycle desc
+                rtl8125_put_rx_buffer(tp, ring, cur_rx, rxb);
+
+                dma_sync_single_range_for_cpu(tp_to_dev(tp),
+                                              rxb->dma,
+                                              rxb->page_offset,
+                                              tp->rx_buf_sz,
+                                              DMA_FROM_DEVICE);
+#else //ENABLE_PAGE_REUSE
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, pkt_size + R8125_RX_ALIGN);
+                if (!skb) {
+                        //netdev_err(tp->dev, "Failed to allocate RX skb!\n");
+                        goto drop_packet;
+                }
+
+                skb->dev = dev;
+                skb_reserve(skb, R8125_RX_ALIGN);
+                skb_put(skb, pkt_size);
+
+                rx_buf_phy_addr = ring->RxDescPhyAddr[entry];
+                dma_sync_single_for_cpu(tp_to_dev(tp),
+                                        rx_buf_phy_addr, tp->rx_buf_sz,
+                                        DMA_FROM_DEVICE);
+                rx_buf = ring->Rx_skbuff[entry]->data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                prefetch(rx_buf - R8125_RX_ALIGN);
+#endif
+                eth_copy_and_sum(skb, rx_buf, pkt_size, 0);
+
+                dma_sync_single_for_device(tp_to_dev(tp), rx_buf_phy_addr,
+                                           tp->rx_buf_sz, DMA_FROM_DEVICE);
+#endif //ENABLE_PAGE_REUSE
+
+#ifdef ENABLE_RX_PACKET_FRAGMENT
+                if (rtl8125_is_non_eop(tp, status)) {
+                        unsigned int entry_next;
+                        entry_next = (entry + 1) % ring->num_rx_desc;
+                        rxb = &ring->rx_buffer[entry_next];
+                        rxb->skb = skb;
+                        continue;
+                }
+#endif //ENABLE_RX_PACKET_FRAGMENT
+
 #ifdef ENABLE_RSS_SUPPORT
-                        rtl8125_rx_hash(tp, (struct RxDescV3 *)desc, skb);
+                rtl8125_rx_hash(tp, (struct RxDescV3 *)desc, skb);
 #endif
+                rtl8125_rx_csum(tp, skb, desc, status);
 
-                        if (tp->cp_cmd & RxChkSum)
-                                rtl8125_rx_csum(tp, skb, desc);
+                skb->protocol = eth_type_trans(skb, dev);
 
-                        skb->dev = dev;
-                        skb_put(skb, pkt_size);
-                        skb->protocol = eth_type_trans(skb, dev);
+                total_rx_bytes += skb->len;
 
-                        if (skb->pkt_type == PACKET_MULTICAST)
-                                RTLDEV->stats.multicast++;
+                if (skb->pkt_type == PACKET_MULTICAST)
+                        total_rx_multicast_packets++;
 
-                        if (rtl8125_rx_vlan_skb(tp, desc, skb) < 0)
-                                rtl8125_rx_skb(tp, skb, ring_index);
+                if (rtl8125_rx_vlan_skb(tp, desc, skb) < 0)
+                        rtl8125_rx_skb(tp, skb, ring_index);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
-                        dev->last_rx = jiffies;
+                dev->last_rx = jiffies;
 #endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
-                        RTLDEV->stats.rx_bytes += pkt_size;
-                        RTLDEV->stats.rx_packets++;
-                }
+                total_rx_packets++;
 
-                cur_rx++;
-                entry = cur_rx % ring->num_rx_desc;
-                desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
-                prefetch(desc);
+#ifdef ENABLE_PAGE_REUSE
+                rxb->skb = NULL;
+                continue;
 #endif
+
+release_descriptor:
+                rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                continue;
+drop_packet:
+                RTLDEV->stats.rx_dropped++;
+                RTLDEV->stats.rx_length_errors++;
+                goto release_descriptor;
         }
 
         count = cur_rx - ring->cur_rx;
@@ -15280,6 +16733,10 @@ process_pkt:
                 printk(KERN_INFO "%s: no Rx buffer allocated\n", dev->name);
         ring->dirty_rx += delta;
 
+        RTLDEV->stats.rx_bytes += total_rx_bytes;
+        RTLDEV->stats.rx_packets += total_rx_packets;
+        RTLDEV->stats.multicast += total_rx_multicast_packets;
+
         /*
          * FIXME: until there is periodic timer to try and refill the ring,
          * a temporary shortage may definitely kill the Rx process.
@@ -15291,7 +16748,7 @@ process_pkt:
                 printk(KERN_EMERG "%s: Rx buffers exhausted\n", dev->name);
 
 rx_out:
-        return count;
+        return total_rx_packets;
 }
 
 static bool
@@ -15483,12 +16940,12 @@ static void rtl8125_down(struct net_devi
 
         //rtl8125_delete_link_timer(dev, &tp->link_timer);
 
+        netif_carrier_off(dev);
+
         netif_tx_disable(dev);
 
         _rtl8125_wait_for_quiescence(dev);
 
-        netif_carrier_off(dev);
-
         rtl8125_hw_reset(dev);
 
         rtl8125_tx_clear(tp);
@@ -15547,7 +17004,7 @@ static void rtl8125_shutdown(struct pci_
 
         rtnl_lock();
 
-        if (tp->DASH)
+        if (HW_DASH_SUPPORT_DASH(tp))
                 rtl8125_driver_stop(tp);
 
         rtl8125_set_bios_setting(dev);
@@ -15570,21 +17027,6 @@ static void rtl8125_shutdown(struct pci_
 }
 #endif
 
-/**
- *  rtl8125_get_stats - Get rtl8125 read/write statistics
- *  @dev: The Ethernet Device to get statistics for
- *
- *  Get TX/RX statistics for rtl8125
- */
-static struct
-net_device_stats *rtl8125_get_stats(struct net_device *dev)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-        struct rtl8125_private *tp = netdev_priv(dev);
-#endif
-        return &RTLDEV->stats;
-}
-
 #ifdef CONFIG_PM
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
@@ -15621,10 +17063,10 @@ rtl8125_suspend(struct pci_dev *pdev, pm
 
         set_bit(R8125_FLAG_DOWN, tp->task_flags);
 
-        netif_tx_disable(dev);
-
         netif_carrier_off(dev);
 
+        netif_tx_disable(dev);
+
         netif_device_detach(dev);
 
 #ifdef ENABLE_PTP_SUPPORT
@@ -15638,7 +17080,7 @@ rtl8125_suspend(struct pci_dev *pdev, pm
 
         rtl8125_powerdown_pll(dev, 1);
 
-        if (tp->DASH)
+        if (HW_DASH_SUPPORT_DASH(tp))
                 rtl8125_driver_stop(tp);
 
         rtnl_unlock();
